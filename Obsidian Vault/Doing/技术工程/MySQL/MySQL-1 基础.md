
## 客户端

- **流程图**
  
	![[MySQL 客户端.png|400]]


### 连接器

	连接器负责跟客户端建立连接、获取权限、维持和管理连接。

#### wait_timeout

	客户端如果长时间没动静，连接器就会自动断开。默认时间8h
	
	建议使用长连接解决频繁重建过程，但长也会面对长时间积累下来内存上涨问题，解决方案主要有：
	1. 定期断开
	2. 可以在每次执行一个比较大操作后 mysql_reset_connection 来重新初始化

### 解析与优化
#### 查询缓存

	简单来说就是把查询语句和查询结果以key-value形式保存下来。
	但这种方式下value表数据一旦更新就会清空缓存，往往弊大于利
#### 分析器

#### 优化器

	优化器是在表里面有多个索引决定使用哪个索引；或者一个语句有多表关联join的时候决定各个表连接顺序
	
```sql
	-- 是先从t1过滤还是t2，优化器会优化
	mysql> select * from t1 join t2 using(id) where t1.c = 10 and t2.d = 20;
```


#### 执行器


### 存储引擎

	也可以叫做表处理器，用于记录、读取一行行的表记录；包含了几十个底层函数如 “读取索引第一条内容”、“插入记录” 
	MySQL支持多种存储引擎
		1. `InnoDB`：具备外键、支持功能的事物存储器
		2. `MEMORY`：置于内存的表
		3. `MyISAM`：主要的非事务处理存储引擎？？


-  **InnoDB  vs  MyISAM**
  
	1.  InnoDB 支持事务，MyISAM 不支持
		 1.  `MyISAM` 用表锁定，不利于事务的并发执行
		 2.  `MyISAM` 用缓冲池提高速度，在执行事务时需先写入缓冲再刷到磁盘，不适合事务频繁提交和回滚（InnoDB不也是？？？）
		 3.  `MyISAM` 数据文件和索引文件分开，不支持原子性恢复（？？？）
	2.  `InnoDB` 是聚集索引，`MyISAM` 是非聚集索引；`MyISAM` 采用了一种索引和数据分的存储方式
	3.  `InnoDB` 最小粒度是行锁，`MyISAM` 的最小粒度是表锁
	
	![[Pasted image 20250306145734.png|400]]


- **MyISAM**

	![[Pasted image 20250228115935.png|500]]
## 存储


	MySQL存储要回答的几个问题（持续更新ing...）
	
	1. 怎么支持ACID？也就是写入过程保证 原子性、持久性、隔离性 和 一致性 ...
	2. 怎么支持高并发流量？写速度怎么保证、有没有缓存、怎么解决读写一致问题 ... 
	3. 怎么保证高可用？宕机后怎么恢复、水平扩展怎么做的 ... 

 
### 一次更新

	1. 客户端处理
	2. 写入 buffer pool
	3. 记录变更前 undo log
	4. 记录 redo log
	5. 刷脏
	6. 记录binlog 
	7. 主从同步
	

-  **数据更新流程**
	![[image-MySQL-2 存储-20240527235945983.png]]


## 查询

	MySQL查找要回答的几个问题（持续更新ing..）
	
	1.  查询路子怎么样的？怎么支持更多更快、以及范围查找模糊匹配...等能力
	2.  怎么解决高流量
	3.  怎么保证高可用（宕机后怎么自动恢复）


### 访问方式

	1. const：常数级，代表查询的代价可以忽略不计的如主键查或唯一索引
	2. ref：二级索引执行回表查
	3. ref_or_null：二级索引字段 + NULL（在记录最前面）
	4. range：范围查询
	5. index：不用回表的二级索引查询
	6. all：扫描聚簇索引


### 查询SQL

	SELECT、FROM、JOIN、WHERE、GROUP BY、HAVING、ORDER BY、LIMIT 执行顺序
	
	1. FROM：第一步识别查询涉及的表
	2. JOIN：优化表查询效率
	3.  WHERE：对 JOIN 操作的结果过滤
	4.  GROUP BY：条件过滤后分组数据
	5.  HAVING：分组后继续筛选
	6.  SELECT：选择特定的列
	7.  ORDER BY：拿到列后进行排序
	8.  LIMIT：限制返回的行数


-  **Join**


-  **Order By**

