## 5.1、数据存储

###  5.11、InnoDB 行

InnoDB支持了4种不同类型的行格式，分别是 `Compact`、`Redundant`、`Dynamic` 和 `Compressed` 

```mysql
-- MySQL指定行格式方式 ROW_FORMAT = COMPACT

mysql> CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
```

#### COMPACT

![[Compact行格式.png|500]]

##### 1、额外信息
 
 -  **1.1 变长字段长度**
 
	MySQL支持的一些变长的数据类型如VARCHAR(M)、VARBINARY(M)、各种TEXT类型等。

-  **1.2 NULL值列表**

-  **1.3 记录头信息**

	`2个预留位` : 待定的
	`delete_mask`：该记录是否被删除
	`min_rec_mask`：B+树的每层非叶子节点种最小记录都会添加该标记
	`n_owned`：当前记录拥有的记录数。在数据页分组成索引的时候标记当前组的数量
	`heap_no`：当前记录在记录对的位置。
	`record_type`：记录类型（0 - 普通记录；1 - B+树非叶子节点记录；2 - 最小记录；3 - 最大记录）
	`next_record`：当前记录的真实数据到下一条记录的地址偏移量。比方说第一条记录的`next_record` = `32`，意味着从第一条记录的真实数据的地址处向后找`32`个字节便是下一条记录的真实数据。就是链表
##### 2、真实数据

-  **2.1 列值**

-  **2.2 隐藏列**

	MySQL会为每个记录默认添加一些隐藏列，如
	  `row_id`：唯一标识一条记录
	  `transaction_id`：事务ID
	  `roll_pointer`：回滚指针

#### 其他格式
##### Redundant
是MySQL5.0前的格式，比较老了

###  5.12、InnoDB 页

-  **页格式**

	那 InnoDB 会一条一条的把记录从磁盘上读出来么？-- 不，那样会慢死
	InnoDB采取的方式是：将数据划分为若干个页，以 页 作为 磁盘 和 内存 之间交互的基本单位，页的大小一般为 _**16**_ KB

-  **Page Directory 页目录**

	记录存放在数据页后，那下一个问题是怎么在页面里找到这些记录？一条一条的过去不现实
	
	要用到页目录来快速定位记录 ，要达成一个目录的效果大概需要这几步：
	1.  将所有正常记录划分为几个组
	2.  每组的最后一条记录（也就是组内最大的那条记录）的头信息种 n_owned，表示该组有多少记录
	3.  每组的最后一条记录的 地址偏移量 存放到页尾的 Page Directory

	![[MySQL页目录.png|600]]

	这样找到一个数据页中指定记录的位置主要分为两步：
	1.  通过二分法确定记录所在的槽，并找到该槽所在分组中主键值最小的记录
	2.  通过记录 `next_record` 遍历该槽所在组的记录


-  **Page 数据页**

	1.  `File Header`：38字节，？
	2.  `Page Header`：56字节
	3.  `Infimum + supermum`：最小记录 和 最大记录
	4.  `User Records`：大小不确定，存储记录的核心字段。大小从Free区域部分迁移过来
	5.  `Free Space`：大小不确定
	6.  `Page Directory`：大小不确定
	7.  `File Trailer`：8字节

-  **存储估算**

	1.  非叶子节点：假设存储一个主键（bigint 8bit） + 一个指针（6bit），16KB * 1024 / ( 8+ 6 )  = 1170 即根节点可以扩展出1170个子节点，同理2层 1170 * 1170 = 136w 节点（页）
	2.  叶子节点：假设单行1KB（10个bigint），一页16条记录，
	   
	   故3层索引结构可以存储记录：1170 * 1170 * 16 = 2000w，也就是说4层内还无需分表


## 5.2、数据查询

### 5.21 构建索引


![[MySQL索引树.png]]

**索引构成**

	1. 页号：并不是连续，只是建立双向链表关系
	2. record_type：0（用户记录）、1（目录项纪录）、2（最小记录）、3（最大记录）
	3. 下一页最小值
	4. 下一页号

**B+树**

	1.  B+树是一颗平衡树，每个叶子节点到根节点的路径长度相同，查询效率高
	2.  B+树非叶子节点：不存储实际数据，可以存放更多索引（vs 红黑树）
	3.  B+树非叶子节点：使用指针连接子节点，可以快速支持范围查询和倒序
	4.  B+树叶子节点：所有关键字都在，查询时只需要遍历一遍叶子节点即可
	5.  B+树叶子节点：都按照关键字大小顺序存放，支持排序 （vs 红黑树）
	6.  B+树叶子节点：之间通过双向链表链接，方便进行范围查询


### 5.22 使用索引

**0、索引查询**
  
	1. 确定目录项记录页
	2. 目录项 -->  真实页
	3. 真实页 --> 分组槽slot
	4. 分组槽slot --> 具体页

**1、目录项**

	目录项包括两部分
	1.  页的用户记录中最小的主键值，用key来表示
	2.  页号，用 page_表示

![[image-MySQL-5 InnoDB 索引-20240602161411817.png|500]]


**2、目录项 --> 记录页**

	根据二分法快速确定出主键值为`20`的记录在`目录项3`中，因为 `12 < 20 < 209`，它对应的页是`页9`


 **3、记录页 --> 分组槽**

	`InnoDB`会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个`槽`。
	再通过二分法确定该记录所在的槽

![[image-MySQL-5 InnoDB 索引-20240602161809122.png]]


 **4、分组槽 --> 具体记录**

	通过记录的 `next_record` 属性遍历该槽所在的组中的各个记录

#### 聚簇索引

**主键值的大小记录和排序**

	1. 页内记录按照主键大小单向链表排序（为什么不是双向？）
	2. 目录页也按照主键大小双向链表排序
	3. 存放记录页的不同层次也按照页中主键大小双向链表排序


**叶子节点存储的是完整的用户记录**

#### 二级索引

（参考MyISAM设计，要查数据必要先查询数据所在的地址，因为它的节点存的并不是数据而是地址）

**二级**

	1. 同上（主键 换成 对应的列）
	2. B+树叶子节点存储只是 列 + 主键 两列的值

**回表**

	当我们根据非聚簇索引查询的时候，会先查询到主键的值，
	再通过主键查询一次才能得到想要的数据，这个过程就是回表。
	可以依赖索引覆盖、索引下推等优化


#### 联合索引

先把各个记录和页按照 a 列排序，在记录相同的情况下采用 b 列排序

#### 索引选择

-  **全值匹配**

-  **匹配左边的列**

-  **匹配列前缀**

-  **匹配范围值**

-  **索引交集** 


### 5.23 索引失效

**explain**

	1. id：执行计划中唯一标识
	2. select_type：操作类型，包括 SIMPLE、PRIMARY、SUBQUERY、UNION 等
	3. table：涉及的表
	4. partitions：涉及的分区
	5. type：查询时所使用的索引类型，包括ALL、index、range、ref、eq_ref、const等
		1.  system：系统表，少量数据，不需要磁盘IO
		2.  const：常数索引，如唯一索引
		3.  eq_ref：唯一索引扫描
		4.  ref：非唯一索引
		5.  range：范围扫描
		6.  index：走全索引，如不符合前缀匹配导致的只返回索引值匹配（注意 index 不是索引匹配）
		7.  all：全表扫描
	6. possible_keys：可能被使用索引
	7. key：选择使用索引
	8. key_len：索引长度，越短越高
	9. ref：那些列或常量被用来与key列中命名的索引比较
	10. rows：扫描的行数
	11. filtered：过滤的行数占扫描行数的百分比，值越大查询越准确
	12. extra：额外信息如 Using index、Using filesort、Using temporary等
		1.  Using where：非索引字段查询 或 未索引覆盖
		2.  Using index：使用覆盖索引无需回表
		3.  Using index condition：索引使用条件过滤，如索引下推情况对如like未能走索引的也进行过滤
		4.  Using where; Using index：查询的列被覆盖且where是索引列但不是前缀参数
		5.  Using join buffer：连接缓存
		6.  Using temporary：临时表存储查询结果，如排序或分组？？？
		7.  Using filesort：文件排序而非索引排序，如无法索引排序时
		8.  ... 


-  **图**
  
	![[image-MySQL-5 InnoDB 索引-20240604170246246.png|600]]
	![[image-MySQL-5 InnoDB 索引-20240604170214147.png]]

 **索引失效**

	1.  利用 explain 的 key（索引值） + type（索引类型） + extra（索引方式）确定是否走索引
		1.  type = ALL, key = NULL, extra = Using where  为没走索引
		2.  type = index, key = index_abc, extra = Using index  走索引
	2.  分析没走索引原因
		1.  索引是否匹配最左原则
		2.  索引区分度不高
		3.  表太小
		4.  查询语句使用函数等

 **选错索引**

	1.  区分度：区分度越高优化器越倾向使用，如`kdt_id + state` 这种就直接走全表扫描
	2.  选择性：过滤数据的能力 -> 扫描行数
	3.  索引覆盖
	4.  ORDER BY：倾向使用能排序的索引
	5.  索引类型：如B-TREE、HASH
	6.  JOIN查询：块排序时候考虑驱动表
	7.  索引的大小和深度
	8.  ...

**order by id**

	MySQL为了避免额外的排序，如果这个字段有索引，那么优化器为了减少file sort，会愿意选择使用这个索引
	
	如 `select ... order by id limit 100` 会默认 `key = PRIMARY（主键索引）`，然后在加上 `extra = Using where（使用where过滤不走二级索引）`，直接导致慢查。优化的话就可以使用索引字段进行排序

### 5.24 热点数据

 **问题**

	1.  锁竞争，热点数据更新update会有排他锁，这就会导致大量请求被阻塞
	2.  占用数据库连接，当有大量update更新同一条记录被阻塞，他们持有连接不会释放导致连接不够
	3.  耗尽CPU，大量锁等待就会导致大量自旋，从而导致消耗大量CPU
	4.  死锁风险
	5.  索引开销维护大
	6.  主从不一致，热点数据频繁更新，如果在主从复制出现延迟的情况下，会放大不一致概率

