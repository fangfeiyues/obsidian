
## 1、客户端

- **流程图**
  
	![[MySQL 客户端.png|400]]


### 连接器

	连接器负责跟客户端建立连接、获取权限、维持和管理连接。

#### wait_timeout

	客户端如果长时间没动静，连接器就会自动断开。默认时间8h
	
	建议使用长连接解决频繁重建过程，但长也会面对长时间积累下来内存上涨问题，解决方案主要有：
	1. 定期断开
	2. 可以在每次执行一个比较大操作后 mysql_reset_connection 来重新初始化

### 解析与优化
#### 查询缓存

	简单来说就是把查询语句和查询结果以key-value形式保存下来。
	但这种方式下value表数据一旦更新就会清空缓存，往往弊大于利
#### 分析器

#### 优化器

	优化器是在表里面有多个索引决定使用哪个索引；或者一个语句有多表关联join的时候决定各个表连接顺序
	
```sql
	-- 是先从t1过滤还是t2，优化器会优化
	mysql> select * from t1 join t2 using(id) where t1.c = 10 and t2.d = 20;
```


#### 执行器


### 存储引擎

	也可以叫做表处理器，用于记录、读取一行行的表记录；包含了几十个底层函数如 “读取索引第一条内容”、“插入记录” 
	MySQL支持多种存储引擎
		1. `InnoDB`：具备外键、支持功能的事物存储器
		2. `MEMORY`：置于内存的表
		3. `MyISAM`：主要的非事务处理存储引擎？？


-  **InnoDB  vs  MyISAM**
  
	1.  InnoDB 支持事务，MyISAM 不支持
		 1.  `MyISAM` 用表锁定，不利于事务的并发执行
		 2.  `MyISAM` 用缓冲池提高速度，在执行事务时需先写入缓冲再刷到磁盘，不适合事务频繁提交和回滚（InnoDB不也是？？？）
		 3.  `MyISAM` 数据文件和索引文件分开，不支持原子性恢复（？？？）
	2.  `InnoDB` 是聚集索引，`MyISAM` 是非聚集索引；`MyISAM` 采用了一种索引和数据分的存储方式
	3.  `InnoDB` 最小粒度是行锁，`MyISAM` 的最小粒度是表锁
	
	![[Pasted image 20250306145734.png|400]]


- **MyISAM**

	![[Pasted image 20250228115935.png|500]]


## 2、存储


	MySQL存储要回答的几个问题（持续更新ing...）
	
	1. 怎么支持ACID？也就是写入过程保证 原子性、持久性、隔离性 和 一致性 ...
	2. 怎么支持高并发流量？写速度怎么保证、有没有缓存、怎么解决读写一致问题 ... 
	3. 怎么保证高可用？宕机后怎么恢复、水平扩展怎么做的 ... 

 
### 一次更新

	1. 加载缓存数据
	2. 记录变更前 undo log
	3. 写入 buffer pool 内存数据
	4. 记录 redo log
	5. redo log 写入磁盘
	6. 提交事务，binlog 写入磁盘
	7. 主从同步


-  **更新流程**
	![[image-MySQL-2 存储-20240527235945983.png]]


## 3、查询

	MySQL查找要回答的几个问题（持续更新ing..）
	
	1.  查询路子怎么样的？怎么支持更多更快、以及范围查找模糊匹配...等能力
	2.  怎么解决高流量
	3.  怎么保证高可用（宕机后怎么自动恢复）


### 访问方式

	1. const：常数级，代表查询的代价可以忽略不计的如主键查或唯一索引
	2. ref：二级索引执行回表查
	3. ref_or_null：二级索引字段 + NULL（在记录最前面）
	4. range：范围查询
	5. index：不用回表的二级索引查询
	6. all：扫描聚簇索引


### 查询SQL

	SELECT、FROM、JOIN、WHERE、GROUP BY、HAVING、ORDER BY、LIMIT 执行顺序
	
	1. FROM：第一步识别查询涉及的表
	2. JOIN：优化表查询效率
	3.  WHERE：对 JOIN 操作的结果过滤
	4.  GROUP BY：条件过滤后分组数据
	5.  HAVING：分组后继续筛选
	6.  SELECT：选择特定的列
	7.  ORDER BY：拿到列后进行排序
	8.  LIMIT：限制返回的行数


-  **Join**


-  **Order By**


-  **limit**

	select * from users limit 10000,20
	1.   数据表取出所有符合的数据
	2.  将数据按照 ORDER BY 排序
	3.  根据 LIMIT 跳过前 10000 条，返回后 20 条 -> 深翻页
	
	优化
	

# 4、缓存

InnoDB 用缓冲池 buffer pool 管理内存，能加快读写性能，但也必然会带来一些挑战。见 [[Redis-0 缓存的伤寒杂病]]

## Buffer Pool

### 基础信息

**作用**

	MySQL的数据都是存储在磁盘上的（Memory引擎除外），如果每次数据查询和修改都和磁盘交互的话，性能是很差，为了提升读写性能，Inndb引擎就引入了一个中间层 Buffer Pool

**设置**

```SQL
	[server]
	innodb_buffer_pool_size = 268435456 （ 265M，默认128M ）
```

### 链表结构

![[MySQL-4 Buffer Pool.png|600]]

#### Free链表

![[MySQL-4 Buffer Pool-1.png|600]]

LRU管理，线型管理缓存的数据

按照链表依次向后查？？？

#### Flush链表


### 读写过程

 **读过程**
 
	1.  MySQL会先检查Buffer是否存在本次数据，命中则直接返回
	2.  如果未命中，MySQL会从磁盘读取数据
	3.  读取数据页会被放入Buffer，同时数据返回给应用

 **写过程**

	1.  MySQL先将要修改的数据页加载Buffer Pool （不一定，见下 change pool ）
	2.  在Buffer Pool中对数据页进行修改，但不会立即写回磁盘
	3.  如果Buffer Pool数据页被修改过，MySQL会将这个页标记为“脏页” （Dirty Page）
	4.  脏页被写回磁盘

### 缓存优化

**存在问题**

	1.  预读失效：预读会数据加载到buffer中，如果这些数据用不到可能导致缓存命中率下降
	2.  全表扫描：大量数据加载如全表扫描，会换血一批数据导致缓存命中率受影响

 **优化**

	  通过配置 `innodb_old_blocks_time` 来按一定比例 Free链表 分成两截，
	  代表频率使用高的 `热数据（young区域）`  和  频率一般的 `冷数据（old区域）`
	  
	  这样就能保证数据来先到 old区 不影响正常的 young区


 **进一步优化**

	 防止 `young` 区域的热点数据被频繁移动到头部，只有被访问的缓存页位于`young`区域的`1/4`的后边，才会被移动到`LRU链表`头部


### 刷盘策略

 **刷盘时机**

	1.  redo log 满了的情况下，会主动触发脏页刷新到磁盘（这种情况整个系统就不能再接受更新）
	2.  Buffer Pool 空间不足需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘
		`为什么不直接淘汰内存？下次查询的时候从磁盘读取再结合redo log
	3.  MySQL 认为空闲时后台线程回定期将适量的脏页刷入到磁盘；即使非空闲时也会见缝插针地刷盘；
	4.  MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；

**刷盘影响**
  
	1.  一个查询要淘汰的脏页个数太多，会导致查询时间变长
	2.  日志写满，则会全部堵住，写性能为0

**解决方案**

	1.  设置redo log写磁盘能力 `innodb_io_capacity`  看SSD硬盘
	2.  控制脏页比例 `innodb_max_dirty_pages_pct` 默认75%


## Change Pool

 **更新步骤**
  
	1、如果数据在内存，则直接更新
	2、否则会缓存操作到 change buffer，来避免读磁盘数据到内存
	3、再等下次访问数据页时，会把数据读到内存再触发 merge，或 后台定期merge


**使用条件**

	1、唯一索引不能，由于数据唯一性限制
	2、change buffer 用的是 buffer pool内存，不能无限大，`innodb_change_buffer_max_size` 控制

**使用场景**

	1、 写多读少的业务如账单、日志等。写多可以一次性merge；读少可以减少merge

