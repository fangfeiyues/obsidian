- **描述**

```text
给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文串。返回 `s` 所有可能的分割方案。
```

- **代码**

```java
boolean[][] f;  
List<List<String>> ret = new ArrayList<>();  
List<String> ans = new ArrayList<>();  
int n;  
  
public List<List<String>> xxx_partition_131(String s) {  
    n = s.length();  
    f = new boolean[n][n];  
    for (int i = 0; i < n; ++i) {  
        Arrays.fill(f[i], true);  
    }  
    // 1、动态找到字符的回文串（对比下面方式，推荐这种方式 简答明了）  
    for (int i = n - 1; i >= 0; --i) {  
        for (int j = i + 1; j < n; ++j) {  
            f[i][j] = (s.charAt(i) == s.charAt(j)) && f[i + 1][j - 1];  
        }  
    }  
    // 2、深度递归树找到[i,j]  
    partition_dfs(s, 0);  
    return ret;  
}  
  
private void partition_dfs(String s, int i) {  
    if (i == n) {  
        ret.add(new ArrayList<>(ans));  
        return;    
        }  
    // for循环下一个树节点是从上一个的尾开始  
    for (int j = i; j < n; ++j) {  
        if (f[i][j]) {  
            ans.add(s.substring(i, j + 1));  
            partition_dfs(s, j + 1);  
            // ans作为唯一一个list存储，下一层节点结束的时候要移除再返回上一层  
            ans.remove(ans.size() - 1);  
        }  
    }  
}
```


-  **思考**

	dp[i] -> dp[i+1]，是通过 s.charAt(i) == s.charAt(j) 左右夹击得到