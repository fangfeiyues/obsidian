## 1、类加载

### 类加载机制

- **1、加载**

	将类的`.class`文件加载到JVM，在这个阶段JVM会根据类的全限定名获取定义该类的二进制字节流，并将这个字节流所代表的静态存储结构转换为方法区运行时数据

- **2、连接**

	验证：确保被加载的类的正确性，符合JVM规范
	
	准备：为类的静态变量分配内存即static字段，并将其初始化为默认值
	
	解析：把类中的符号引用转换为直接引用（类或接口、字段、类方法、接口方法、方法类型）

- **3、初始化**

	为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化

- **4、使用**

	类访问方法区内的数据结构的接口， 对象是Heap区的数据

- **5、卸载**

	结束生命周期

![[image-JVM-02 对象初始化与加载-20240428113641860.png|600]]

### 类加载器

- **Bootstrap ClassLoader（启动类加载器）**

	负责加载存放在 `JDK\jre\lib` JDK代表JDK的安装目录下，或被 `-Xbootclasspath` 参数指定的路径中的，并且能被虚拟机识别的类 如rt.jar，所有的java.* 开头的类均被 `Bootstrap ClassLoader` 加载 。

启动类加载器是无法被Java程序直接引用的

- **Extension ClassLoader（扩展类加载器）**

	该加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载 `JDK\jre\lib\ext` 目录中，或者由 `java.ext.dirs` 系统变量指定的路径中的所有类库如javax.* 开头的类，开发者可以直接使用扩展类加载器

- **Application ClassLoader（应用程序类加载器）**

	该类加载器由`sun.misc.Launcher$AppClassLoader`来实现，它负责加载用户类路径(ClassPath)所指定的类
	开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器

- **自定义类加载器**

	因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:
	- 在执行非置信代码之前，自动验证数字签名。
	- 动态地创建符合用户特定需要的定制化构建类。
	- 从特定的场所取得java class，例如数据库中和网络中。

![[image-类加载机制-20240425004106023.png|500]]
### 双亲委派

-  **作用** 

	1.  一个类在同一个加载器中具有唯一性。避免被篡改
	2.  避免重复加载提升性能

- **SPI打破双亲委派** 

	1. 第一次破坏：双亲模型还没引入
	2. 第二次破坏：没有办法解决用户基础类又要调用用户类的代码。为了解决这个问题有了线程上下文加载器如JNDI, JDBC等 。如 DriverManager 位于rt.jar包下由BootStrap类加载器加载，而Driver接口是位于服务商提供的Jar包下。根据类加载机制当被类加载的类引用了另一个类的时候，虚拟机就会使用转载第一个类的加载器转载被引用的类。但其只负责rt.jar所以需要子类加载器（线程上下文加载器AppClassLoader）去加载这就破坏了双亲加载模式
	3. 第三次破坏：代码热替换，模块热部署。在更新一个模块的时




## 2、对象加载过程

singleton = new Singleton() 过程

1、虚拟机遇到new指令，到常量池定位到这个类的符号引用
2、检查符号引用代表的类是否被加载、解析、初始化过
3、虚拟机为对象分配内存
4、虚拟机将分配到的内存空间都初始化为零值
5、虚拟机对对象进行必要的设置
6、执行方法，成员变量进行初始化
7、将对象的引用指向这个内存区域

简化来说：JVM为对象分配内存M --> 在内存M上为对象初始化 --> 将内存M的地址赋给singleton变量

## 3、内存分配

