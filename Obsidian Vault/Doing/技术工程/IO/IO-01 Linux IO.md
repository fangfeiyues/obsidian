
## IO模型

### 同步阻塞IO

-  **举例**

	吃饭点餐，你点单后，一直等店家做好，期间什么也做不了。（你是应用级别，店家是操作系统级别）


-  **图例**

	![[image-IO-01 Linux IO-20240609155322458.png|500]]

### 同步非阻塞IO

-  **举例**

	吃饭点餐，你点单后，每隔一段时间去问问有没有做好，期间可以做点其他事

-  **图例**

	![[image-IO-01 Linux IO-20240609160841578.png]]


### 多路复用IO

-  **举例**

	吃饭点餐，你点单后，原来收银和做餐都是一个人完成，人多后他成了瓶颈，所以专门找个收银员自己专注做餐。但你还是阻塞等待

-  **图例**

	使用 select 或 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当套接字可读时，再使用 recvfrom 把数据从内核复制到进程中
	
	![[image-IO-01 Linux IO-20240609160943703.png]]


### 信号驱动式IO

-  **举例**

	吃饭点餐，你点单后，引入一个叫号系统，点完单就可以做自己事等待叫号就行

-  **图例**

	![[image-IO-01 Linux IO-20240609162005799.png]]



### 异步IO


-  **举例**

	吃饭点餐，直接去美团下单，然后做其他事，等待上门服务

-  **图例**

	![[image-IO-01 Linux IO-20240609162154918.png]]


## Reactor模型

	Reactor是基于事件驱动的，处理海量I/O事件
### 传统IO模型

-  **说明**

	每一个请求到来时，大致都会按照：请求读取->请求解码->服务执行->编码响应->发送答复 这个流程去处理
	![[image-IO-01 Linux IO-20240609164320376.png]]

-  **问题**

	服务器会分配一个线程去处理，如果请求暴涨起来，那么意味着需要更多的线程来处理该请求。若请求出现暴涨，线程池的工作线程数量满载那么其它请求就会出现等待或者被抛弃

### Reactor模型

- **说明**

	每个小任务都可以使用非阻塞的模式，然后基于异步回调模式，这样就大大提高系统的吞吐量
	
	1、**Reactor**：负责监听和分配事件，将I/O事件分派给对应的Handler。包括建立就绪、读就绪、写就绪等
	2、**Acceptor**：处理客户端新连接，并分派请求到处理器链中。
    3、**Handler**：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理
    
    传统模型是快，因为都是单线程同步处理不用切换上下文资源稳定，但没法支持大规模请求；而Reactor利用异步回调，能支持大量并发，但会增加处理时间，用时间换数量


-  **单Reactor单线程模型**

	Reactor线程负责多路分离套接字，accept新连接，并分派请求到handler。如Redis
	![[image-IO-01 Linux IO-20240609165027034.png]]
	1. Reactor对象通过select监控连接事件，收到事件后通过dispatch进行转发。
	2. 如果是连接建立的事件，则由acceptor接受连接，并创建handler处理后续事件。
	3. 如果不是建立连接事件，则Reactor会分发调用Handler来响应。
	4. handler会完成read->业务处理->send的完整业务流程。


-  **单Reactor多线程模型**

	handler处理池化
	![[image-IO-01 Linux IO-20240609165102117.png]]


-  **多Reactor多线程模型**

	主从Reactor模型： 主Reactor用于响应连接请求，从Reactor用于处理IO操作请求，读写分离
	![[image-IO-01 Linux IO-20240609165204217.png]]



## Java NIO

NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。

传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。

NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的
