
「work」

   1. AI含硅率:
      1、AI SQL，通过现有表结构 + 提示词 -> 生成数据查询SQL
      2、一键Agent，通过 RAG、Function Calling等实现问题排查

   2. 贷超: 数据运营的日常（逾期、还款计划）

   3. 有赞寄件: 3月补扣&退款（可否AI串行流程）

   4. 上门取件: 上门取件增加商家端价值透传项目发布、取件码


--------------------------------【项目】--------------------------------


「1、one by one」-> 自信、聪明


   1、增值：架构演变、分布式事务等

      1. 退货包运费

         1.1 理赔领域优化
            a) 对外不够解耦：补贴，概念入侵
            b) 对内不够内聚：理赔金，依赖在保险底层

         1.2 离线风控
            出现率 -> 每日定价 -> 加工成指标 -> 产品配置策略 -> 关联具体事件

         1.3 权益配置
            a) 升级版：定价&


      2. 有赞寄件 & 上门取件

         2.1 分布式事务
            a) TCC，如 try网络超时失败 -> cancel -> try继续执行导致的事务悬挂
            b) 2PC，强一致性、单点故障、不适合长事务
            c) Saga，异步消息执行、存在事务中间态脏数据
            d) 本地消息表，本地数据库扫表、重复消息幂等等

         2.2 组件开放性
            a) 节点开放：倒置依赖
            b) 流程开放：组件可插拔、数据通用化


   2、分销员：分布式一致性、高流量等

      1. 架构演变（记不清了，慎用）

         1.1 归因路径：归因中心如CPS、云分销 -> 店铺设置 -> 订单商品类型 -> 客户归属分销员

         1.2 计费模式：
            a) 路径依赖：店铺设置 -> 商品佣金类型如比例、固定分红 -> 分销员等级取金额 
            b) 计费模型：因子参数 + 计算模版即可，不依赖任何原数据 或者 是可插拔倒置依赖的

      2. 分布式一致性

         2.1 多版本 -> 可重复读 -> 通用性的链式快照存储结构，避免HBase的value存储挂机（版本快照&瞬时快照）
            a) 链式存储：HBase、Redis、File..
            b) 失败重试策略：3次等（参考Dubbo源码设计）
            c) 负载均衡策略：权重、平均

         2.2 状态机 -> 解决乱序，保证最终的一致性 -> 模型的可复用

      3. 高流量高并发

         3.1 限流：Tesla
            a) 漏斗
            b) 令牌桶

         3.2 MQ分流： Redis zset滑动窗口（重点实现！） + VIP通道
            a) 删除窗口外数据：zremrageByScore key min max
            b) 统计窗口内数量：zcard
            c) 新请求加入窗口：zadd(key,ms,ms) -> 高并发情况下考虑原子性，用Lua脚本

         3.3 MySQL优化
            a) HotKey：在内核层批量提交
            b) 索引优化
               1. 索引覆盖
               2. 索引失效：最左匹配、区分度不够、函数、
               3. 选错索引：order by id、left join、
               4. limit深翻页：-> 延迟加载
               
      4. 资损防控：离线脚本对账如数据统计 + 实时校准平台


   3、AI：技术、应用（如下）


「2、AI」 -> 每天都要看到进步！

   05.19｜ RAG大致实现


--------------------------------【记录】---------------------------------
 

「1、减肥」

   05.12｜162，重启爬楼，本周目标-5
   05.14｜158，两天晚上没怎么吃，控制住！
   05.16｜158.8 昨晚都没吃，不知怎么还是没减下去..


「2、关系」

   1. 自我｜降低期待、保护自己 -> 好像要明说要表达？
   2. 差劲｜什么都不行（懒惰、素质..） -> 做好自己



23.给你一个链表数组，每个链表都已经按升序排列。
请你将所有链表合并到一个升序链表中，返回合并后的链表。

示例 1：

输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
示例 2：

输入：lists = []
输出：[]
示例 3：

输入：lists = [[]]
输出：[]

public ListNode mergeKLists(ListNode[] lists) {
        
}



25.给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换

输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]

public ListNode reverseKGroup(ListNode head, int k) {
        
}

