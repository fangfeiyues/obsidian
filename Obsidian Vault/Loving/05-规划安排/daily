
「work」
   1. 含硅率：4月搞个AI产品 
      1. 简历自动筛选：捞简历 -> 工作流筛选 -> API筛选
      2. 日常抽奖
      3. 智能预警
      4. 财务问答
      5. 小红书账号运营
      6. 电商攻坚客群识别
      7. 客服机器人
      8. AI CR
   2. 贷超：核心流程状态回查 - done  
   3. 有赞寄件：2月对账脚本
   4. 包运费商家版

--------------------------------【项目】--------------------------------


「1、面试」

   liuyanghao
      1. 分布式锁：redis -> redission、
      2. ThreadLocal：实现
      3. 阻塞队列：

   wangchunhua





--------------------------------【记录】---------------------------------
 

「1、坚持」
   1. 每天运动锻炼｜45min, 强壮体魄
   2. 每天政经历文｜45min, 广阔视野


「2、规划」

   ~ 01.30（27 = 15 + 「8 + 4」）-> 60 + 8
      1. 薪资：18 = 1.5 * 12
      2. 年终：12 = 3 * (2 + 2)
      3. 投资：4 = 4 + 10｜x > 0.15？


「3、RUN」

   1、概览 -> 深挖

      a）面聊(5min)：经验的匹配度

      b）经历(10min)：要性

      c）项目(35min)：聊场景 -> 够抽象

         1、增值业务

         2、云分销

         3、分销员稳定性


   2、8 GU

      「1、高与满的问题」

         「1、SQL慢」
            1、索引（最左匹配、索引覆盖、深度翻页->延迟加载、join、orderby id、filesort ）
            2、锁（for update、）
            3、数据量过大（数据统计表->离线+实时、hotUpdate->RDS Proxy限制并发、缓存击穿->数据下泻 ..）

         「2、MySQL连接满」
            1. 基于缓存，进行热点数据更新（可行，刷脏复杂度要细聊）
            2. 通过异步，将高并发消息削峰填谷（不可，异步后消息量依旧很高）
            3. 拆分数据，分散到不同库、不同表中，减少并发（不可，分库后跨库查询问题）
            4. 合并请求，批量执行的方式降低冲突（可行，）

         「3、MySQL CPU高」
            1. 单行锁并发太高 -- 合并更新

         「4、CPU高」
            1、cpu利用率 = cpu非空闲时间/cpu空闲时间 * 100%｜vmstat 2 2 
                  --  每两秒收集一次信息（包括memory,swap,io,system,cpu..）
            2、top -> top -Hp 1893 -- 查看进程到线程的资源占用情况（包括cpu占用，memory占用）
            3、jstack -l 12345 -- 查看线程堆栈信息 nid 16进制，如 RUNNABLE 具体代码行、deadlock（死锁） wait to lock
            3、arthas: thread -n 3  -- 查看最忙的3个线程

         「5、OOM」

            1. 自动dump文件：-xx:HeapDumpOnOutOfMemoryError 
            2. 手动dump文件：jmap -dump:live,format=b,file=xxxheap.bin <pid>
            3. MAT(Memory Analysic Tool) 内存分析
               1. 死锁
               2. 大对象

         「6、FullGC频繁」

            1. dump & 分析内存情况
            2. 大对象是否存在？
               1. LIST<object>是否频繁添加对象没移除
               2. 分页查询没做好分页，导致一次查询数量过多，如传参没带id等参数导致数据全部搂出来

      「2、不一致的问题」

      「3、JVM」

         1、JIT: just in time
            1.1 缓存热点代码：大概解释了接口调用第一次一般很慢，但几次后就快了起来
            1.2 逃逸分析：分析是哪种逃逸方式（全局逃逸、参数逃逸、不逃逸） --> 进行锁消除、栈上分配等优化
            1.3 方法内联：A内部调用B，直接内联到A，较少调用消耗

         2、内存区域
            2.1 程序计数器：存储正在执行的字节码指令地址，是只读存储器
            2.2 虚拟机栈：存储局部变量，如
            2.3 本地方法栈：存储本地代码Native Method参数和局部变量，一般是C语言
            2.4 堆：存储对象实例，最大一块，有垃圾回收机制
            2.5 方法区：存储已被加载的类信息、常量、静态变量等，实现形式有多种比如堆、永久代、元空间等。
                JDK1.6->1.7：方法区的字符串常量池、静态变量 --> 内存堆空间
                JDK1.7->1.8：被移除，堆外内存存储运行时常量池、代码缓存等元空间数据
            2.6 运行时常量池：存储编译阶段生成信息，如符号引用常量和字面量，是方法区的一部分

         3、CMS vs G1

         4、JVM参数


   3、专题
      
      06.24｜Redis集群怎么分片、怎么保证一致性，虚拟节点怎么用、新增删除节点怎么操作？怎么扩容设计
      06.24｜2PC、3PC、TCC、Saga？系统实际保证分布式一致性方案
      06.24｜分布式锁 -> 超时、重入、抢占、redlock
      06.25｜Dubbo、MQ Filter 负载均衡、高可用（master挂了）、分布式（单个读写压力大）
      06.26｜分布式 -> MQ分布式架构 -> vs redis/mysql -> 分布式一致性（高可用性=主从复制+读写分离，分布式=自动故障转移）
      06.26｜Dubbo 3.0 Tripe协议、Stream
      06.26｜DDD的实践与应用 -> 遇到的问题 -> 过程的挑战 -> 收益:领域划分清晰 (直接效果线上问题减少 + 项目推进节奏加快)
      06.27｜MVCC -> 事务 -> 日志 -> 锁
      06.27｜分布式限流 -> 限流算法 -> Redis zset -> 跳表
      06.27｜MySQL线上排查
      06.30｜PDD：线程、并发、TOP K (PDD,WYY -> 过二 + 三)
      07.01｜秒杀系统全链路设计
      07.01｜并发锁 synchronized vs lock vs redission 比较
      07.01｜redis -> 10亿uv
      07.02｜100T数据在4C8G机器中，如何找出出现频率最高的
      07.02｜CompletableFuture
      07.08｜计费｜结算，结算时间这个概念该谁去吃？（停摆后的重新开始）
      07.09｜分销问题的深度到底在哪？看看最近做的项目 + 行业分销处理 .. 感觉还是领域模型这块
      07.09｜REVIEW ALL 8 GU
      07.17｜Redis在什么情况下数据错乱丢失
      07.17｜MQ在什么情况下消息丢失
      07.17｜MQ的分布式Q&A 5+
      07.24｜MySQL索引、HABSE存储结构等基础
      07.25｜下探业务深度
      07.25｜AI学习计划
      07.29｜PDD、DW、GD all_dead (对所有的项目推翻->重塑)







（一）退货包运费

通过为消费者提供退换货后的包运费能力，来收取商家服务费。
在技术上，搭建基础服务、保单、理赔等核心子域来建设清晰的领域模型，并进一步解决理赔归因、保险核心、对外开放等难题。

invoke com.youzan.pay.creditpayprod.api.loan.LoanMarketTaskCallBackService.loanFaceDataFix("{\"bizNo\":\"250409122604262219\",\"imgUrl\":\"https://img01.yzcdn.cn/upload_files/2025/04/09/FmartPjBwyQWUEc-W_yqFhRI85sV.jpg\",\"message\":\"成功\",\"outBizNo\":\"1250407384452000001\",\"outBizType\":\"yz_loan_supermarket\",\"outUserId\":\"220402344518262185\",\"result\":true,\"score\":\"0.99154675\",\"sourceAppCode\":\"1\"}")



invoke LoanMarketLoanService.apply({"loanTransNo":"1250407384452000001","userId":13914678253,"verifyList":["AGREEMENT_COMMON","FACE_CHECK"]})







