
## 内存结构






![[image-JVM-01 内存结构&模型-20240426201639985.png]]




## 内存模型


![[image-JVM-01 内存结构&模型-20240426202013784.png|400]]



```
 为了解决读写速度都接近处理器运算的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了
```

内存模型可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。

```
   Java线程之间的通信由Java内存模型（简称JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）
```


为了保证线程之间通信的可见性、原子性就出现了以下三个关键字

### volatile

解决两个问题：

1. 可见性问题。？？？
2. 重排序问题。这可以理解是一个衍生问题了，即在全局变量赋值并作为判断的时候需要考虑禁止重排序volatile修饰，通过内存屏障方式实现

### final
也是保证可见性的一种：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去，那么其他线程就能看到这个值。

### synchronized

### final
也是保证可见性的一种：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去，那么其他线程就能看到这个值。

### synchronized