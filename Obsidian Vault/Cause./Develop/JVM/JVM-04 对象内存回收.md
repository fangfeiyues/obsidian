## 1、垃圾可达性分析

引用计数法：可以用来判断对象被引用的次数，在任何某一具体时刻如果引用次数为0，则代表可以被回收。


## 垃圾回收算法

### 标记-清除

### 标记-复制

### 标记-整理


## 垃圾收集器

### Serial 收集器

```
   Serial收集器是单线程收集器，“单线程”的意义不仅仅是它只会使用一个CPU或一条收集器去完成垃圾收集工作，更重要的是它在垃圾收集的时候必须暂停其他所有工作的线程。
```

“-XX:+UseSerialGC”：添加该参数来显式的使用Serial垃圾收集器

![[image-JVM-05 内存管理-20240425004403396.png|600]]

### ParNew 收集器

并行（Parallel）：指多条垃圾收集器并行工作，但此时用户线程仍然处于等待状态

### Parallel Scavenge 收集器

```
  Parallel Scavenge收集器关注点是达到一个可控制的吞吐量（吞吐量=运行用户代码时间 / （运行用户代码时间+ 垃圾收集时间）），而其他收集器关注点尽可能的缩短垃圾收集时用户线程的停顿时间。
```

### Serial Old 收集器

这是一个老年代收集器，用“标记-整理”算法。同样是一个单线程收集器

内存，存储

单次FullGC更快

### CMS 收集器

CMS收集器是以获得 _**最短回收停顿时间**_ 为目标的收集器。基于“标记-清除”算法

![[image-JVM-05 内存管理-20240425004439201.png|600]]


运行过程可分为：

1. 初始标记。标记一下GC Roots能直接关联到的对象，这个速度很快
2. 并发标记。进行GCRoots Tracing
3. 重新标记。修正并发期间因用户线程继续运作而导致标记产生变动的那一部分对象的标记
4. 并发清除。

其中初始标记和重新标记仍然需要 “Stop The World”

缺点：
1. CMS收集器对CPU资源非常敏感。虽然在两个并发阶段不会导致用户线程停顿但是因为占用了一部分线程而导致应用程序变慢，总吞吐量下降
2. CMS是无法处理浮动垃圾。由于并发清除阶段用户线程还在运行，伴随着程序还在产生新的垃圾
3. 由于CMS收集器是一个基于 _标记-清除_ 算法的收集器，那么意味着收集结束会产生大量碎片

### G1收集器


![[image-JVM-05 内存管理-20240425004510656.png]]


目标：建立可预测的停顿模型。

实现：G1跳出老年&新生代这个牢笼，它可以面向任何部分组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块垃圾数量多回收收益最大。 G1收集器去跟踪各个Region里面垃圾堆的价值大小，价值即回收收获的空间大小以及回收所需要的经验值。然后维护在一个优先队列里每次根据用户设定允许的收集停顿时间优先处理那些价值收益最大的Region.

使用G1收集器时Java堆的内存布局与其他收集器有很大的区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留着新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，他们都是一部分Region（不需要连续）的集合。


## 垃圾回收机制

### 新生代回收机制

Minor GC触发机制：当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满如果是Survivor满不会引发GC。

### 老年代回收机制

Full GC 触发机制
1.  调用System.gc时系统建议执行Full GC但不是必然执行
2.  老年代空间不足
3.  方法区不足
4.  通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5.  由Eden区、survivor space1（From Space）区向survivor space2（To Space）区复制时对象大小大于To Space可用内存则把该对象转存到老年代，且老年代的可用内存小于该大小
6.  永久代满时也会引发Full GC，会导致Class、Method元信息的卸载


垃圾清理算法

"分代收集理论"

### 标记-清除

```
   分为“标记”和“清除”两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
```

会存在两个问题：

1.  效率问题。标记和清楚两个过程效率都不高
2.  空间问题。标记清楚后会产生大量的碎片

### 标记-复制

就是默认的Eden和Survivor的8:1比例。

能通过标记存活对象并整体复制到另一块空间区域的方式解决碎片化问题

### 标记-整理

```
   其标记的过程还是与“标记-清除”一样，但后续不是直接对可回收对象进行清理，而是让所有活的对象都向内存空间一端移动然后清理掉边界以外的内存。
```




## Full GC

几个区别
1.  Full GC == Major GC指的是对老年代、永久代的stop the world的GC
2.  Full GC的次数 == 老年代GC时 stop the world的次数
3.  Full GC的时间 == 老年代GC时 stop the world的总时间
4.  CMS 不等于Full GC，我们可以看到CMS分为多个阶段，只有stop the world的阶段被计算到了Full GC的次数和时间，而和业务线程并发的GC的次数和时间则不被认为是Full GC
5.  Full GC本身不会先进行Minor GC，我们可以配置，让Full GC之前先进行一次Minor GC，因为老年代很多对象都会引用到新生代的对象，先进行一次Minor GC可以提高老年代GC的速度。比如老年代使用CMS时，设置CMSScavengeBeforeRemark优化，让CMS remark之前先进行一次Minor GC**