## 对象是否存活

### 引用计数法

给对象添加一个引用计数器，每当有一个地方引用它，计数器加1，当引用失效，计数器减1。可以用来判断对象被引用的次数，在任何某一具体时刻如果引用次数为0，则代表可以被回收。

### 可达性分析

通过一系列称为 GC Roots 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明次对象不可用

-  **GC Roots**

	GC Roots必须要枚举完整，否则就可能错过应存活的对象，
	1.  Class，由系统类加载器加载的对象，这些是不能被回收的
	2.  Thread，活着的线程
	3.  Stack Local  Java方法的local变量
	4.  JNI Local
	5.  JNI Global
	6.  Monitor Used，被同步锁synchronized持有的对象

- **不足**

	需要全局分析，时间成本高

## 垃圾回收算法

### 标记-清除

分为 标记 和 清除 两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
除了速度快之外还存在两个问题：
1.  效率问题，标记和清楚两个过程效率都不高
2.  空间问题，标记清楚后会产生大量的碎片

### 标记-复制

将内存分为两个区域，新创建的都放其中一块，快满的时候，就将标记存活的对象复制到另一块区域，就是默认的 Eden : Survivor = 8 : 1，这样就能通过标记存活对象并整体复制到另一块空间区域的方式解决碎片化问题，但也存在不足：
1.  浪费了一半的内存空间
2.  复制对象会造成性能和时间上的消耗

![[image-JVM-04 对象内存回收-20240428022945198.png|400]]


### 标记-整理

标记的过程还是与 标记-清除 一样，但后续不是直接对可回收对象进行清理，而是让所有活的对象都向内存空间一端移动然后清理掉边界以外的内存，这样就既没内存碎片也不浪费空间，但太耗时间

![[image-JVM-04 对象内存回收-20240428023308131.png|400]]


## 垃圾收集器

### Serial 

- **定义**

	Serial收集器是新生代单线程收集器，“单线程”的意义不仅仅是它只会使用一个CPU或一条收集器去完成垃圾收集工作，更重要的是它在垃圾收集的时候必须暂停其他所有工作的线程。
	
	标记-复制算法


“-XX:+UseSerialGC”：添加该参数来显式的使用Serial垃圾收集器

![[image-JVM-05 内存管理-20240425004403396.png|600]]

### ParNew 

- **定义**

	Serial的多线程版本，多条垃圾收集器并行工作，但此时用户线程仍然处于等待状态
	
	标记-复制算法

### Parallel Scavenge

-  **定义**

	JDK1.8 默认的新生代算法，和ParNew一样也是多线程运行
	
	标记-复制算法
	
	Parallel Scavenge 关注点是达到一个可控制的吞吐量（吞吐量=运行用户代码时间 / （运行用户代码时间+ 垃圾收集时间）），而其他收集器关注点尽可能的缩短垃圾收集时用户线程的停顿时间。更适合做一些定时任务

### Parallel Old

-  **定义**

	JDK1.8 默认的老年代算法，是 Parallel Scavenge 的老年代版本，同样是一个关注吞吐量的收集器，
	
	标记-整理算法

### Serial Old 

这是一个老年代收集器，用“标记-整理”算法。同样是一个单线程收集器

内存，存储

单次FullGC更快

### CMS 

-  **定义**

	CMS收集器是以获得 **最短回收停顿时间** 为目标的收集器
	
	标记-清除 算法，来缩短停顿时间

-  **过程**

	![[image-JVM-05 内存管理-20240425004439201.png|600]]
	
	1.  初始标记：标记一下GC Roots能直接关联到的对象，这个速度很快
	2.  并发标记：进行GCRoots Tracing
	3.  重新标记：修正并发期间因用户线程继续运作而导致标记产生变动的那一部分对象的标记
	4.  并发清除
	   
	其中初始标记和重新标记仍然需要 “Stop The World”

-  **优缺点**

	1. CMS收集器对CPU资源非常敏感。虽然在两个并发阶段不会导致用户线程停顿但是因为占用了一部分线程而导致应用程序变慢，总吞吐量下降
	2. CMS是无法处理浮动垃圾。由于并发清除阶段用户线程还在运行，伴随着程序还在产生新的垃圾
	3. 由于CMS收集器是一个基于 _标记-清除_ 算法的收集器，那么意味着收集结束会产生大量碎片

### G1

-  **定义**

	JDK 1.9的默认垃圾收集器，使用G1收集器时Java堆的内存布局与其他收集器有很大的区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留着新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，他们都是一部分Region（不需要连续）的集合。
	
	新生代：标记-复制 算法
	老年代：标记-整理 算法

-  **过程**

	![[image-JVM-05 内存管理-20240425004510656.png]]
	
	目标：建立可预测的停顿模型
	
	实现：G1跳出老年&新生代这个牢笼，它可以面向任何部分组成回收集进行回收，衡量标准不再是它属于哪个分代，而是哪块垃圾数量多回收收益最大。 G1收集器去跟踪各个Region里面垃圾堆的价值大小，价值即回收收获的空间大小以及回收所需要的经验值。然后维护在一个优先队列里每次根据用户设定允许的收集停顿时间优先处理那些价值收益最大的Region.


- **优缺点**

1.  并发回收：

## 垃圾回收

### 新生代回收机制

-  **回收算法**

	标记-复制，效率高但会有空间浪费问题，可通过设置Eden区 和 Survivor区 比例降低问题。

-  **垃圾收集器**

	有如 Serial、ParNew、Parallel Sca

-  **Minor GC 触发机制**

	年轻代满时就会触发Minor GC，这里的 年轻代 满指的是 Eden 如果是 Survivor 不会引发GC

-  **分区**

	1、新生代由年轻区 Eden、Survivor区（From，To）组成，比例是8:1:1，可通过参数 -XX:SurvivorRatio 
	2、在 Eden区 内存容量用完，GC发起，非存活对象标记死亡，存活对象移动到survivor区
	3、由于新生代的标记-复制算法，必须要有一块非利用的区域from 或 to 来保证复制移动存活对象

- **担保分配**

	如果Survivor区域空间不够，就要分配给老年代，但老年代也可能存在不足情况，这时候就要做一次担保分配，检查老年代最大可用的连续空间是否大于新生代所有对象总空间。

- **新 to 老的晋升**

	1. `-XX:MaxTenuringThreshold` 控制年龄（躲过GC次数）
	2. `-XX:PretenureSizeThreshold` 设置大对象临界值
	3.  动态年龄判断，如果在survivor空间中小于等于某个年龄的所有对象大小的总和大于survivor空间的一半时就把这些对象全部晋升到老年代

### 老年代回收机制

-  **回收算法**

	标记-整理，效率低了点但减少浪费且不会有碎片，如CMS

-  **垃圾收集器**

	有如 Serial Old、Parallel Old、CMS

-  **Full GC触发机制**

	1.   老年代空间不足
	2.   空间分配担保失败
	3.   永久代空间不足
	4.   System.gc时系统建议执行Full GC但不是必然执行

-  **频繁Full GC**

	QPS 5000 + 100台机器：Full GC一周一次，一次400-700ms；Young GC 100+分钟一次，20ms

### Java引用

-  **强引用**

	默认引用方式，当内存空间不足虚拟机宁愿跑出 OutOfMemoryError错误，使程序异常终止，也不愿靠回收强引用来解决内存不足问题

-  **弱引用**

	如果一个对象只具有弱引用，无论内存充足与否，Java GC后对象如果只有弱引用将会被自动回收
	
	如在 Thread 的 Entry 中，对于 ThreadLocal 使用的弱引用，所以当 ThreadLocal 没有其他引用时候，就会被下一次GC回收。但也会导致 Entry 的 value 没被回收，产生内存泄露
	![[image-JVM-04 对象内存回收-20240428030541838.png]]
	
	ThreadLocal对象为什么会被 栈 和 Entry的key 同时引用？

- **软引用**

	不会保证对象一定不会被回收，只能最大可能保证；特性与弱引用基本一致，区别是软在内存不足才会回收

- **虚引用**

	在任何时候都可能被gc回收，虚引用主要来跟踪对象被垃圾回收


