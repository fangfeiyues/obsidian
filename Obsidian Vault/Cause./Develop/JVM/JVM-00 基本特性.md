
## 平台无关性

平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once，Run Anywhere）

-  **JVM虚拟机**

	Java之所以可以做到跨平台，是因为虚拟机充当了桥梁，他扮演了运行时Java程序与其下的硬件和操作系统之间的缓冲角色。我们可以理解为Java的平台无关性，正是因为JVM平台的有关性。

-  **字节码**

	Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性

-  **Java语言规范**

	比如Java中基本数据类型的值域和行为都是由自己定义的，而C/C++中，基本数据类型是由它的占位宽度决定，占位宽度是由所在平台决定的，如16位计算机上int可能是两字节，32位是4字节。


![[image-JVM-00 基本特性-20240428000602190.png|500]]


## 编译型 vs 解释型

1.  编译：通过`编译器compiler`把高级语言的源代码，直接编译成可以被机器执行的机器码，如C
2.  解释：通过`解释器 interperter`直接解释执行，不需要编译成机器语言，如javascript

	但在Java中为了实现跨平台和提升运行速度，通过 javac 或 Java源代码 先 编译 成字节码，但这个字节码并不是机器码，需要虚拟机来解释执行 ，解释的过程大概是一边翻译成机器码一边执行（编译 -> 解释）
	

## JIT
### 缓存执行

解释过程中发现运行频繁的“热点代码”，然后会通过`即时编译JIT`直接翻译成机器码，被直接执行并缓存起来，下次请求过来即可直接执行

### 逃逸分析
 
 -  **全局逃逸**
 
	对象逃逸出方法或线程的范围，比如被 存储在静态字段 或 作为方法的返回值。这种情况一般不会栈上分配内存，因为会被多线程中

-  **参数逃逸**

	对象被作为参数传递或参数引用，比如 A方法创建参数 传递到 B方法

-  **无逃逸**

	对象可以被标量替换，意味着它的内存分配可以从生成的代码中移除


### 锁消除

在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块使用的所对象是否只能够被一个线程访问而没有发布到其他线程，如果只能被同一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这个取消过程就是锁消除

```java
public voif a(){
	Object a = new Object();
	syncharonized(a){
	 // ...
	}
}

// --> 会优化成
public voif a(){
Object a = new Object();
	// ... (因为a锁只会被方法内访问)
}

```

### 栈上分配

	`在HotSpot虚拟机中，存在JIT优化机制，JIT可能会进行逃逸分析，当经过逃逸分析发现某一个局部对象没有逃逸到线程和方法外的话，那么这个对象就可能不会在堆上分配内存而是栈上分配

