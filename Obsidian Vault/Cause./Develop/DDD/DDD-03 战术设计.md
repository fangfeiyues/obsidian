# 2. 战术落地

## 2.1 分层架构

### I. 分层优点

1. 保持高内聚低耦合的一种技术手段
    1. 战在一个系统的角度：保持Domain层的高内聚低耦合
        1. 保证Domain层App、Infrastructure层的分层必须职责清晰边界清楚
            1. 防止Domain业务扩展到APP。如app直接注入仓储这样就会多了很多的转化组装等。我们定义app层只能调用domain层的三种领域概念：实体行为、聚合行为、领域行为。
            2. Domain层和Infrastructure层：依赖倒置。
        2. Domain内部必须概念清晰边界清楚
    2. 站在某一个业务线的角度：保持核心业务的高内聚低耦合
        1. 产品角度考虑两个业务的边界。
2. 维持公司内部统一技术风格，减少内部沟通成本

### II. 应用层

```
   不使用分层场景分层而是通过「业务对象+场景」的方式让我的application只会做某个业务对象在某个场景下的一件事。
```

1. 编排
    1. 编排的主要对象有三类：实体行为、聚合行为和领域服务
    2. 流程引擎
        1. 流程规则匹配。根据各种组合选择出唯一的一条道
        2. 流程组件执行。唤起需要做的事。难点：上下文传递
2. 事务
3. 抽象领域具体化。领域是抽象的但业务是具体的我们怎么做映射？就是通过应用层如订单类型

### III. 领域层

首先分为三层：核心、通用还是支撑。然后才是业务对象的命名，最后是领域概念的命名

然后就是各个领域概念

1. 实体：entity
2. 聚合：aggr
3. 值对象：vo
4. 领域服务：service
5. 领域工厂：factory
6. 领域事件：event
7. 仓储：repository

领域层主要做的事情就是【内部领域模型 + 领域间的边界】

![[image-DDD-03 战术设计-20240428160854123.png]]


### IV. 基础设施层

建议还是先业务再技术命名

我们希望基础设施层都是一些技术框架，比如远程调用框架、消息队列框架、缓存框架等。

存在的范围：只在本层不会出现在其他层中，即依赖倒置

## 2.2 应用层

描述的是一个业务动作，而业务动作是很难挂到聚合和实体头上的如各种校验

### Application & Domain

```
 回答这个问题很多时候我们只看到了表象即：「App层是用来做流程编排和事务」，其实基于这种思考那么从业务和技术角度看这两者是可以合并一处的，这种分层的根本原因在于App层需要适配各种场景，是我们抽象出的业务对象在不同上下文中的不同表现是需要经常发生变化的。而Domain层是完全面向对象的，是一种稳定抽象的概念。
```

**两者边界：防止Domain层扩散到App层**

罪魁祸首是app能随意对domain的各种概念进行调用

1. app层直接注入仓储repository并在app层进行各种校验、转化、组转等，这样在app层就写了很多业务代码
    
2. app层直接调用工厂维持实体之间关系等。
    
3. ...
    
    这些完全都是领域层应该做的事情但扩散到应用层就会便慢慢的变得不可控，我们约定app层只能调用domain的三种概念：实体行为、聚合行为、领域行为。这样我们就会发现app层会干净很多，没有什么业务代码
    

## 2.3 领域服务层

### 2.3.1 领域服务

一、**几种非领域服务**

1. 技术Service. 比如说远程调用，这种service没有业务含义属于基础设置层
2. 应用Service. 没有业务含义的，只做一些流程编排和事务的事
3. 查询类. 查询对象由领域提供，由应用层组转转化查询的结果
    1. 错误1：领域服务里调用实体方法去查询。可能造成方法非常单调
    2. 错误2：直接去使用Repository去持久化。领域服务是一个动作而动作是不能持久化的只有对象才能持久化

二、**业务角度来说一般会有三种场景使用到领域服务**

1. 承载挂不到业务对象上的动作。如一些校验行为
2. 对领域行为的组装，从而对app层提供通用的领域服务
3. 对下游业务解耦适配。这种情况如果在app层去做就会吃下很多业务逻辑

三、**领域服务的边界**

1. _与应用层边界_：细粒度领域能力的封装以增加复用
2. 与实体层的边界：业务场景 or 抽象
3. _与下游业务边界_：SPI层适配下游业务，其实也就是我们的dependency层

_由上可见：领域服务是一个动词，维护领域内部的领域对象和下游服务边界。_

「领域层与下游服务的边界」

![[image-DDD-03 战术设计-20240428160930475.png]]



「领域层和应用层的边界」

![[image-DDD-03 战术设计-20240428160951392.png]]


```
    比如我们在处理用户业务逻辑校验信息的时候，校验逻辑就应该在用户域（实体）而非业务处理层（领域服务）。这里就涉及到上图说的很关键因素：**业务场景 or 面向领域抽象** 。前者是就该业务场景下该怎么校验用户信息，后者就是抛弃场景而从领域抽象能力角度思考该怎么做。比如如上我们在校验用户信息的时候就应该在用户实体层抽象思考怎么做校验，而不是为了满足业务场景需要做妥协。

    只有这样业务代码才能避免侵蚀领域抽象逻辑达到内聚效果。 所以我们在涉及到Entity层改动的时候要抛弃场景带来的影响，从领域角度出发抽象思考当前实体影响。
```

**四、保证Domain层稳定**

1. 基本的技术手段：分层。尤其清晰app与Domain层，前者做编排后者做模型抽象
2. 基本的业务手段：上下文。绝不吃业务方的逻辑绝不写业务方的代码
    1. 精炼自己的模型
    2. 探索业务方的领域模型
    3. 结合1、2多多思考交易平台和业务方的边界，在交易平台边界之外的绝对不做
3. 基本的定制手段：扩展点（RPC扩展点能力）

![[image-DDD-03 战术设计-20240428161006860.png]]



### 2.3.2 聚合

【定义】

```
  聚合根发起的并维护多个实体间固定业务关系的领域对象。
```

**【聚合的边界】**

1. 聚合的粒度不要太大，秉持一个聚合只维护一种业务关系的原因
    1. 不同的业务逻辑：如订单改价和订单优惠就不适合在一个聚合里，他们本质上没有业务联系。应该适当的拆分成两个聚合这样聚合最小的粒度就只维护一种固定的业务逻辑，聚合之间的编排可由应用层去做
    2. 聚合多个实体：可拆开成多个聚合然后由应用层去编排
2. 聚合的边界
    1. 与应用层的边界 还是订单改价的例子，这里订单价格改动影响到不仅仅是订单还有商品快照那这个逻辑也需要在聚合中吃掉不能放到应用层编排了。简单来说业务要完整
    2. 与实体之间的边界 关单这个动作就不能聚合去做了，简单领域对象行为就可以放在实体层

【**聚合根**】

聚合根一般是业务的发起方，根据这个聚合根能够轻松的找到聚合内的其他实体

聚合根可以是个实体标识也可以是实体对象

### 2.3.3 领域对象-实体

【**实体的构造**】

可以通过Java构造方式

1. 直接new出来
2. 通过构造器构造
3. 托管给第三方构造器

如果要结合当前主流框架（Spring）使用就第三条路子了但实体是有属性行为的直接单例注入会有线程安全问题，可通过工厂方式在ApplicationContext.getBean生成。

【**实体的存储**】

为了解决事务消息的问题可通过监听事务的提交状态如Spring的TransactionSynchronizationManager来

**【实体的获取】**

直接通过repository ？？？

### 2.3.4 值对象

值对象使用的时候注意两点即可：

1. 当前值对象是对一个实体的描述，那么该值对象的所有操作必须都绑定在该实体的身上
2. 对于值对象是一个字段还是一张表，应该灵活处理以性能优先

**使用场景**

Domain层的数据传输

1. DTO层是面对外部不稳定，是为了适配上层业务需要；
2. VO是内部领域抽象使用，是稳定的。

### 2.3.5 工厂

```
 工厂与领域服务（外部），要不要在工厂内感知到领域行为？最好是不要的，这里涉及到很多服务之间行为交互如rt拉长、qps过大等怎么办。那该怎么处理？最好是在流程编排中把这些领域服务信息封装到上下文中那么在工厂里就能直接取出结果
```

### 2.3.6 仓储

几个概念

1. 仓储的返回值是 VO 或 Entity，大部分情况下是 Entity。仓储需要对Entity和VO进行组装
2. DO是和表映射的Java数据载体，一张表对应一个DO
3. Entit（或VO）和DO之间的关系是一对一或一对多的关系