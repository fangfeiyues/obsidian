` 战术设计做了啥？高度抽象.. -- 核心要理清应用->领域->实体间的关系与边界

## 2.1 分层架构

-   **分层优点**

	1.  保持`高内聚低耦合`的一种技术手段
	    1.  战在一个系统的角度：保持`Domain` 高内聚低耦合
	        1.  Domain、App、Infrastructure 层间职责清晰
	            1.  防止`Domain`业务扩展到`APP`，如app直接注入仓储这样就会多了很多的转化组装等。我们定义app层只能调用domain层的三种领域概念：实体行为、聚合行为、领域行为。
	            2.  Domain 和 Infrastructure 的 依赖倒置
	        2.  Domain 层内概念清晰
	        
	    2.  站在某一个业务线的角度：保持核心业务的高内聚低耦合
	        1.  产品角度考虑两个业务的边界
	    
	2.  维持公司内部统一技术风格，减少内部沟通成本

## 2.2 应用层

	描述的是一个业务动作，而业务动作是很难挂到聚合和实体头上的如各种校验

-  **编排 & 事务 & 校验..**

	1、编排的主要对象有三类：实体行为、聚合行为、领域服务
	2、流程引擎
	1.  流程规则匹配，根据各种组合选择出唯一的一条道
	2.  流程组件执行，唤起需要做的事。难点：上下文传递


-  **具象 -> 抽象**

	抽象领域具体化。领域是抽象的但业务是具体的我们怎么做映射？就是通过应用层如订单类型


- **Application ｜ Domain**

```text
    App 和 Domian 的耦合问题
	 1. App层是用来做流程编排和事务，其实基于这种思考那么从业务和技术角度看这两者是可以合并一处的
	 2. 但App层是需要适配各种场景，是我们抽象出的业务对象在不同上下文中的不同表现是需要经常发生变化的
	  而Domain层是完全面向对象的，是一种稳定抽象的概念
	
    所以要防止 Domain层 扩散到 App层，罪魁祸首是app能随意对domain的各种概念进行调用
	 1. App 直接注入repository，并在app层进行各种校验、转化、组转等，这样app层就写了很多业务代码
	 2. App 直接调用工厂维持实体之间关系，app是编排不负责维系实体之间关系，应该由领域服务或聚合完成
	 这都是领域层应该做的事情，但扩散到应用层就会便慢慢的变得不可控，
	 可以约定app层只能调用domain的三种概念：实体行为、聚合行为、领域行为，这样就会发现app层会干净很多
```


- **查询类**

```text
往往说查询类都是一个动作，可能就会把查询类操作定义成领域服务，如app走domian查询entity数据，或 app走domian查repository等，但其实不对，其一是查询链路有点多余，其二领域服务只能是一个动作而查询显然不是。所以查询应该是
要归属到实体或聚合上，即在app层直接走实体类单个查询即可，同样多实体直接聚合
```


## 2.3 领域层

![[image-DDD-03 战术设计-20240428160854123.png|600]]

### 2.3.1 领域服务

#### 含义

- **3种领域服务**

	1. 承载挂不到业务对象上的动作，如一些校验行为
	2. 对领域行为的组装，从而对app层提供通用的领域服务
	3. 对下游业务解耦适配，这种情况如果在app层去做就会吃下很多业务逻辑

- **3种非领域服务**

	1. 技术Service：比如说远程调用，这种service没有业务含义属于基础设置层
	2. 应用Service：没有业务含义的，只做一些流程编排和事务的事
	3. 查询类（查询对象由领域提供，由应用层组转转化查询的结果）
		1. 领域服务里调用实体方法去查询，可能造成方法非常单调
		2. 直接去使用Repository持久化，领域服务是一个动作，而动作是不能持久化的只有对象才能持久化

#### 边界

	1. 与应用层边界：
		1. 我们通常说的场景，其实是应用服务，领域服务只是应用服务下一个步骤
		2. 领域服务往往只做一个操作或动作，但应用服务却做很多如编排、事务、出入参
	2. 与实体层的边界：业务场景 or 抽象 ？？？
	3. 与下游业务边界：SPI层适配下游业务，其实也就是我们的dependency层
	 由上可见：领域服务是一个动词，维护领域内部的 领域对象 和 下游服务 边界

- **应用层｜领域层**

	![[image-DDD-03 战术设计-20240428160951392.png]]


-  **领域｜实体**

	如我们在处理用户业务逻辑校验信息的时候，校验逻辑就应该在用户域的实体而非业务处理层的领域服务，这里就涉及到上图说的很关键因素：业务场景 or 面向领域抽象 
	
	前者是就该业务场景下该怎么校验用户信息，后者就是抛弃场景而从领域抽象能力角度思考该怎么做。我们在校验用户信息的时候就应该在用户实体层抽象思考怎么做校验，而不是为了满足业务场景需要做妥协。
	
	那么我们在写 Domian 层代码的时候，就应该直接面向领域，抛弃场景，只有这样才能避免 业务代码 侵蚀 领域抽象 达到内聚效果。 所以我们在涉及到Entity层改动的时候要抛弃场景带来的影响，从领域角度出发抽象思考当前实体影响。


- **领域层｜下游服务**

	![[image-DDD-03 战术设计-20240428160930475.png]]




#### 稳定

	1. 基本的技术手段：分层 -- 尤其清晰app与Domain层，前者做编排后者做模型抽象
	2. 基本的业务手段：上下文 -- 绝不吃业务方的逻辑绝不写业务方的代码
	    1. 精炼自己的模型
	    2. 探索业务方的领域模型
	    3. 结合1、2多多思考交易平台和业务方的边界，在交易平台边界之外的绝对不做
	3. 基本的定制手段：扩展点（RPC扩展点能力）

	![[image-DDD-03 战术设计-20240428161006860.png]]



### 2.3.2 聚合

-  **定义**

	聚合的作用比较简单，管理实体之间的一种业务关系。我们聚合是看得见的，是以Aggr后缀结尾的类


-  **作用**

	1.  package代表一个虚拟聚合的概念，表达出一种层次结构。不建议 
	2.  一切聚合为主，所有操作必须经过聚合根。不建议 ，实体有职责和权利直接操作属性，聚合只是两个实体时间有固定关系时一种结合方式
	3.  聚合只管理实体之间关系，实体聚合都可以暴露能力，达到高内聚效果。建议 🌹


- **边界**

	1. 聚合的粒度不要太大，秉持一个聚合只维护一种业务关系的原因
	    1. 不同的业务逻辑：如订单改价和订单优惠就不适合在一个聚合里，他们本质上没有业务联系。应该适当的拆分成两个聚合这样聚合最小的粒度就只维护一种固定的业务逻辑，聚合之间的编排可由应用层去做
	    2. 聚合多个实体：可拆开成多个聚合然后由应用层去编排
	2. 聚合的边界
	    1. 与应用层的边界 还是订单改价的例子，这里订单价格改动影响到不仅仅是订单还有商品快照那这个逻辑也需要在聚合中吃掉不能放到应用层编排了。简单来说业务要完整
	    2. 与实体之间的边界，关单这个动作就不能聚合去做了，简单领域对象行为就可以放在实体层


- **聚合根**

	聚合根一般是业务的发起方，根据这个聚合根能够轻松的找到聚合内的其他实体
	聚合根可以是个实体标识也可以是实体对象

### 2.3.3 实体

-  **什么是实体**

	具有唯一标识，可以连续变化的领域元素

- **实体的构造**

	可以通过Java构造方式
	1.  直接new出来
	2.  通过构造器构造
	3.  托管给第三方构造器
	如果要结合当前主流框架（Spring）使用就第三条路子了但实体是有属性行为的直接单例注入会有线程安全问题，可通过工厂方式在ApplicationContext.getBean生成。

- **存储**

	为了解决事务消息的问题可通过监听事务的提交状态如Spring的TransactionSynchronizationManager来

-  **获取**

	直接通过repository ？？？

- **组成**

	领域属性+领域能力


-  **实体与其他元素的边界**

| 其他领域元素 | 关系                   |
| ------ | -------------------- |
| 聚合     | 实体是聚合的元素；聚合不会包含实体的能力 |
| 领域服务   | 使用实体的能力              |
| 值对象    | 值对象描述实体              |
| 工厂     | 简单实体自己创建；复杂的实体由工厂创建  |
| 仓储     | 实体调用仓储进行持久化          |


### 2.3.4 值对象

- **定义**

	1. 当前值对象是对一个实体的描述，那么该值对象的所有操作必须都绑定在该实体的身上
	2. 对于值对象是一个字段还是一张表，应该灵活处理以性能优先

- **使用场景**

	Domain层的数据传输
	1. DTO层是面对外部不稳定，是为了适配上层业务需要；
	2. VO是内部领域抽象使用，是稳定的。

### 2.3.5 工厂

 工厂与领域服务（外部），要不要在工厂内感知到领域行为？最好是不要的，这里涉及到很多服务之间行为交互如rt拉长、qps过大等怎么办。那该怎么处理？最好是在流程编排中把这些领域服务信息封装到上下文中那么在工厂里就能直接取出结果
### 2.3.6 仓储

- **概念**

	1.  仓储的返回值是 VO 或 Entity，大部分情况下是 Entity。仓储需要对Entity和VO进行组装
	2.  DO是和表映射的Java数据载体，一张表对应一个DO
	3.  Entit（或VO）和DO之间的关系是一对一或一对多的关系


## 2.4 基础设施层

建议还是先业务再技术命名

我们希望基础设施层都是一些技术框架，比如远程调用框架、消息队列框架、缓存框架等。

存在的范围：只在本层不会出现在其他层中，即依赖倒置


## 资料参考


-  **DDD + 大众点评交易系统**

	https://mp.weixin.qq.com/s/_VehzjU22Z1AUAPrEoswHQ
	![[image-DDD-03 战术设计-20240513165925248.png]]


-  **DDD + 美团B端营销系统**

	https://mp.weixin.qq.com/s/Iyk48w8vbzofIrzKBwLCAQ
	
	[[DDD-01 概况]]




