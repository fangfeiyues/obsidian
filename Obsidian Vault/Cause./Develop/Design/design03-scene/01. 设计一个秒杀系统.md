## 实现

### 过程 -> 异步

	 用户发起秒杀 
	 —> 服务校验（链式校验） 
	 —> 返回秒杀价格 
	 —> 提交订单
	 —> 订单处理库存扣减等
	 
	![[image-01. 设计一个秒杀系统-20240701201858151.png|600]]

	1. 资源限流：用户请求存储在队列内一旦请求超过队列长度则限流处理直接返回失败
	    实现：zk实现一个分布式队列，通过监听队列的节点变化判断队列长度是否达标
	2. 为限流后的用户生成一个token，由前端轮训结果
	3. 服务端异步消息削峰。秒杀商品不会太多如1w件，1w的并发还是有压力的。可行
	4. 异步处理消息
		- 判断活动是否已经结束
	    - 判断本次请求是否处于系统黑名单
	    - 扣减缓存中的秒杀商品的库存数量
	5. 秒杀结算

## 问题


一个秒杀系统有几个特点：
1.  高并发瞬时流量
2.  热点数据
3.  数据量大
4.  库存的正确扣减
5.  黄牛抢购
6.  重读下单
7.  对普通交易的影响


### 高并发流量

-  **流量过滤**

	![[image-01. 设计一个秒杀系统-20240701203910561.png|600]]
	
	1.  前端HTML页缓存
	2.  Nginx 流量负载还有过滤
	3.  后端分布式限流策略
	4.  本地缓存、分布式缓存


-  **热点数据**

	预热


-  **请求量大**

	1、分库分表
	
	2、库存分割？
	
	`将秒杀商品的库存进行“分割”，每分割后的库存使用商品id加上一个数组标识来存储这样在对库存的每个Key进行Hash运算的时候得到的Hash结果是不一样的，这就说明存储商品库存的Key有很大概率不在Redis的一个槽位，以来提升Redis的读写并发量。如原来的商品id为10001库存为1000件，此时分割为5份每份200件此时我们的存储信息为（10001_0, 200），（10001_1, 200）
	
	`在真正处理库存信息时，可以先从Redis中查询出秒杀商品对应的分割库存后的所有Key，请求数量对从Redis中查询出的秒杀商品对应的分割库存后的所有Key的长度进行求模运算，得出的结果为0，1，2，3，4。再在前面拼接上商品id就可以得出真正的库存缓存的Key。此时，就可以根据这个Key直接到Redis中获取相应的库存信息 --> 可能导致某些库少卖


-  **库存扣减**

	正常的扣减，会在高并发的情况下，发生超卖情况。需要实现库存扣减的原子性和有序性
	1.  原子性：库存查询 -> 库存判断 -> 库存扣减，都是一个原子操作，过程不会中断
	2.  有序性：多个并发操作要排队
	   
	   
	1、数据库扣减，为了保证超扣少扣就需要加锁
	1.  悲观锁：强迫阻塞并且排队，可能拖垮数据库
	2.  乐观锁：版本控制会存在大量失败重试，也会阻塞
	3.  不加锁：`update ... set count = count - 1 where count > 1` 也会依赖数据库更新
	
	2、缓存扣减：借助单线程特性 + Lua脚本原子性保证
	
	![[image-01. 设计一个秒杀系统-20240701235142734.png|500]]
	
	
	3、Redis + MySQL
	1.  先在 Redis 扣减，扛住并发流量
	2.  再发送一个MQ消息 --> 失败的话，会导致少卖问题，就需要补偿
	3.  接受消息后，做真正的扣减及业务逻辑
	   ![[image-01. 设计一个秒杀系统-20240701235428904.png]]
	   
	4、不用分布式锁而用Lua脚本，是减少网络交互消耗
