
## 内存模型

```
  JMM（Java内存模型）定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地变量，本地内存中存储了该线程以读/写共享变量的副本。
```

Java内存模型就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证一致性的机制及规范

Java内存模型规定了，所有的共享变量都存储在内存中，每个线程还有自己的工作内存，线程对变量的所有操作都必须在工作内存，而不能直接读写主内存。不同线程间也无法直接访问对方工作内存的变量，线程间变量的传递需自己的工作内存和主内存之间进行同步

JMM作用于工作内存和主存之间数据同步过程，它规定了如何做数据同步以及什么时候数据同步

JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等问题

![[image-Concurrent-02 内存模型-20240429020257338.png|400]]


## 多核CPU带来的问题

### 1、多级缓存与一致性问题


### 2、CPU时间片与原子性问题


### 3、指令重排与有序性问题

- **数据依赖性**

	如果两个操作访问同一个变量且这两个操作中有一个为写操作，此时两个操作之间就存在数据依赖性。

- **as-if-serial**

	不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变。

- **程序顺序规则**

- **重排序对多线程的影响*

	![[image-Concurrent-02 内存模型-20240429020340523.png|500]]

	可能对 1，2操作或3，4操作发生重排序。



## 特性

### 原子性

monitor_enter 和 monitor_exit 两个指令保证原子性

### 可见性

Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值

volatile 可以在被其修饰的变量在被修改后立即同步到主内存，被其修饰的变量在每次使用之前都从主内存刷新，因此可以保证多线程操作时变量的可见性。除了volatile，synchronized和final也可以实现

### 有序性

-  **volatile & synchronized** 

	volatile 会禁止指令重排序
	synchronized 会保证同一时刻只允许一条线程操作


-  **final**

	对于final域编译器和处理器要遵守两个重排序规则
	1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
	2. 初次读一个包含final域的对象的引用与随后初次读这个final域，这两个操作之间不能重排序


### happens-before原则

-  **单线程可见性**

	不管怎么重排序，单线程执行结果都不能被改变。无论编译器和处理器如何优化都必须遵守 as-if-serial

-  **多线程可见性**

	如果一个操作A “happen-before” 另一个操作B，那么A的结果对B是可见的