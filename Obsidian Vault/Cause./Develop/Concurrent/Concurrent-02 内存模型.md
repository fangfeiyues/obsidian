

## 两个关键问题

并发编程需要处理两个关键问题：**线程之间如何通信及线程之间如何同步**。


### **通信**

以共享内存和消息传递的机制进行通信

1. 共享内存：线程之间共享程序的公共状态
2. 消息传递：线程必须通过发消息来显示进行通信

### **同步**

程序用于控制不同线程间的操作发生的相对顺序的机制

1. 在共享内存并发模型里同步是显示的，需显式制定某个方法或代码需要在线程之间互斥
2. 在消息传递并发模型里是隐式进行的

## Java内存模型的抽象结构

```
  JMM（Java内存模型）定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地变量，本地内存中存储了该线程以读/写共享变量的副本。
```



![[image-Concurrent-02 内存模型-20240429020257338.png|400]]



## 重排序

### 数据依赖性

如果两个操作访问同一个变量且这两个操作中有一个为写操作，此时两个操作之间就存在数据依赖性。

### as-if-serial语义

不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变。

### 程序顺序规则

### 重排序对多线程的影响

![[image-Concurrent-02 内存模型-20240429020340523.png|500]]

可能对 1，2操作或3，4操作发生重排序。

## 数据一致性

## volatile的特性

volatile写-读建立的happens-before关系

### volatile写-读的内存语义

内存语义：当写一个volatile变量时，JMM会把线程对应的本地内存中的共享变量刷新到主内存。

为了实现volatile内存语义JMM会分别限制这两种类型的重排序类型。编译器在生成字节码时会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

## final域的重排序

对于final域编译器和处理器要遵守两个重排序规则

1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
2. 初次读一个包含final域的对象的引用与随后初次读这个final域，这两个操作之间不能重排序