## 事务的特性

### 原子性

-  **含义**

	转账过程要么成功要么失败，不会存在中间转了一半的情况，这种规则称为原子性
	MySQL在实际处理过程中可能任一步骤，如先修改缓存页、刷盘发生意外数据库错误、操作系统错误、断电等，就需要把已经做了的恢复到没执行之前

（依赖 redo log）

### 隔离性

-  **含义**

	转账步骤一般会先读再写，在读写过程保证不会被其他操作所影响，则称为隔离性

（依赖 锁机制 和 MVCC 机制）

### 一致性

-  **含义**

	转账过程中如账户余额不能小于0这些数据库约束，称为一致性。
	MySQL一致性保证主要两方面
	1、数据库本身约束，如主键约束、唯一约束等
	2、业务代码层约束，如分布式一致性
	3、同时 原子性 和 隔离性 都会对一致性产生影响

（依赖 undo log 回滚机制）

### 持久性

-  **含义**

	转换的结果永远保留没，称为持久性

（依赖 redo log）

## 事务的隔离级别

### 读未提交 RU

发生`脏读`：读到未提交的内容后其发生回滚等造成相当读到一个不存在的数据。

发生`脏写`：一个事务修改了另一个未提交事务修改过的数据

原因：没有MVCC快照，读的都是实时提交数据。

### 已提交读 RC

-  **解决的问题**

	只能读已提交数据，可解决脏读问题

- **发生的问题**

	发生`不可重复度`：一个事务前后两次读取的内容不一致，原因是每次重新读都会生成快照，那么就会读取到新快照之前修改的最新提交视图

- **RC vs RR**

	1.  提高并发，RC不会带来 间隙锁 和 GAP锁问题
	2.  减少死锁，锁多了那么死锁的风险也随之加大
	3.  加大不可重复读风险，这个其实还好可以用乐观锁标记

### 可重复读 RR

-  **RR 与 默认隔离级别**

	在主从复制的binlog 格式为 statement 的时候（即为原SQL）
	![[image-MySQL-6 InnoDB 事务-20240527200520140.png|600]]
	简单来说，就是为了避免因数据同步后未锁到间隙而导致最终提交的结果不一致

- **RR 与 幻读**

	1.  快照读：MVCC通过事务版本解决幻读
	2.  当前读：间隙锁通过锁方式解决幻读
	3.  快照读 + 当前读：可能发生幻读
	
	![[image-MySQL-6 InnoDB 事务-20240527195818772.png|600]]
	
	*这样在事务1 和 事物2 的两次查询结果并不一样，就是因为中间的 update 是当前读操作*


### 串行化 Serializable


## MVCC

### Undo log

`undo log`是一种用于回退的日志，在事务没提交之前，MySQL会先把数据记录到undo log日志文件里，当事务回滚或数据库奔溃时，可以用 undo log来回退。这些提交前记录的日志，也是用于MVCC实现

那么一条记录同一时刻可能被多个事务操作，undo log也会有一条记录的多个快照，那么在这一时刻SELECT进行快照读的时候，读取的是那个？

### 隐式字段

	通过隐式的字段，把 undo log的快照链，连接起来

-  **隐藏列**

	数据库记录中都包含两个必要的隐藏列
	
	- `trx_id`：一个事务对某条聚簇索引记录进行改动时，都会把该事务的 `事务id` 赋值给 `trx_id` 隐藏列。
	- `roll_pointer`：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 `undo日志` ，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息

-  **快照链**

	![[image-MySQL-6 InnoDB 事务-20240527203013150.png|600]]


### Read View

最核心的问题：有了快照链后，下一步怎么判断链中的哪个版本是可见的

-  **ReadView**
  
	1. `m_ids`：在生成 ReadView 时当前系统活跃的读写事务 trx_id 列表
	2. `min_trx_id`：在生成 ReadView 时当前系统中活跃的读写事务中最小的事务ID，也就是 m_ids 最小值
	3. `max_trx_id`：生成 ReadView 时系统中应该分配给下一个事务的ID值
	4. `creator_trx_id`：生成该 ReadView 的事务id

-  **版本判断**

	判断事务记录的某个版本是否可见时候，只需要按照下边的步骤
	
	1.  如果被访问版本的 `trx_id = creator_trx_id` ，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问
	   
	2.  如果被访问版本 `trx_id < min_trx_id`，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问
	   
	3.  如果被访问版本的 `trx_id >= max_trx_id`，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问
	   
	4.  如果被访问版本的  `min_trx_id < trx_id < max_trx_id`，
		1. `trx_id in m_ids` 说明创建 ReadView 时生成该版本的事务 **还是活跃**的，该版本不可以被访问
		2. `trx_id not in m_ids`说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问
		   
	
	总结来说，一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况
	1.  版本未提交，不可见
	2.  版本已提交，但在视图创建之前提交的，不可见
	3.  版本已提交，但在视图创建之前提交的，可见
	![[image-MySQL-6 InnoDB 事务-20240530010109723.png]]


- **RC vs RR**

	`READ COMMITTED` 和 `REPEATABLE READ` 视图区别就是它们生成ReadView的时机不同
	
	1. READ COMMITTED（RR） 读提交在事务内做读取操作时每次都生成一个 ReadView，这样它总是读到最新提交的（在 m_ids）内，就可能读到别事务提交的数据导致不可重复读
	   
	2. REPEATABLE READ（RC） 不可重复读则是在一个事务内做查询，都是第一次读的 ReadView，这样它的提交数据就永远都是第一次生成的，也就不会有不可重复读的问题


**案例**

	![[image-MySQL-6 InnoDB 事务-20240530114002400.png|600]]
	1.  事务A启动时候，B、C未提交则不可见，最终还是1
	2.  事务B更新数据都是先读后写，而且是当前读，所以先拿到2再更为3，那么事务读到自己的值就是3


	![[image-MySQL-6 InnoDB 事务-20240530114215725.png|600]]


	![[image-MySQL-6 InnoDB 事务-20240530135122344.png|600]]
	事务C不是立马提交
	1.  事务A，还是1
	2.  事务B，当前读必须加锁但锁在C还未释放，所以要等到C释放才行。