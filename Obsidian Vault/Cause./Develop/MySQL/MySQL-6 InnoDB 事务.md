## 事务的特性

### 原子性

-  **含义**

	转账过程要么成功要么失败，不会存在中间转了一半的情况，这种规则称为原子性
	MySQL在实际处理过程中可能任一步骤，如先修改缓存页、刷盘发生意外数据库错误、操作系统错误、断电等，就需要把已经做了的恢复到没执行之前

（依赖 redo log）

### 隔离性

-  **含义**

	转账步骤一般会先读再写，在读写过程保证不会被其他操作所影响，则称为隔离性

（依赖 锁机制 和 MVCC 机制）

### 一致性

-  **含义**

	转账过程中如账户余额不能小于0这些数据库约束，称为一致性。
	MySQL一致性保证主要两方面
	1、数据库本身约束，如主键约束、唯一约束等
	2、业务代码层约束，如分布式一致性
	3、同时 原子性 和 隔离性 都会对一致性产生影响

（依赖 undo log 回滚机制）

### 持久性

-  **含义**

	转换的结果永远保留没，称为持久性

（依赖 redo log）

## 事务的隔离级别

### 读未提交 RU

发生`脏读`：读到未提交的内容后其发生回滚等造成相当读到一个不存在的数据。

发生`脏写`：一个事务修改了另一个未提交事务修改过的数据

原因：没有MVCC快照，读的都是实时提交数据。

### 已提交读 RC

解决：MVCC读取快照

发生`不可重复度`：一个事务前后两次读取的内容不一致

原因：每次重新读都会生成快照，那么就会读取到新快照之前修改的最新提交视图

### 可重复读 RR

解决：每个事务只在开始的时候生成快照，解决上诉问题

发生`幻读` ？不会
原因：与标准SQL不同，MySQL在RR级别已经解决幻读问题

解决：

1. MVCC：通过版本视图保证在RR级别下一个事务的两次读都是都同样结果
2. Gap锁（见 [锁](https://www.notion.so/aec8e61924314389a970c2020db82446?pvs=21) ）

### 串行化 Serializable



## MVCC

对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：

- `trx_id`：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的`事务id`赋值给 `trx_id` 隐藏列。
- `roll_pointer`：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到`undo日志`中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息

### **事务id (trx_id)**

-  **生成规则**

	只有在事务对表中的记录做改动时才会为事务分配一个唯一的事务id
	
	1.  对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增，删，改操作时才会为这个事务分配一个事务id，否则是不分配的。
	2.  对于读写事务，只有在它第一次对某个表（包括用户创建的临时表）执行增，删，改操作时才会为这个事务分配一个事务id。

-  **解决什么问题**

	实现实现事务并发处理，解决读写之间的并发问题如脏读，不可重复读，幻读等。
	所以可以用 "MVCC + 乐观锁或悲观锁" 解决 写-写，写-读 之间的并发问题。

### **版本链（roll_pointer）**

-  **生成规则**

	对于每次对表记录的改动都会形成一个链条
	
	1. trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给 trx_id 隐藏列
	2. roll_pointer：每次对某条聚簇索引记录进行改动时都会把旧版本信息写入到undo日志，然后这个隐藏列相当于一个指针，可以通过它来找到该记录修改前的信息

### MVCC

解决最核心的问题：需要判断一下版本链中的哪个版本是当前事务可见的。

**ReadView**

```
 对于Read Uncommitted(读未提交) 的隔离级别来说 直接读取最新的版本即可；Serializable 隔离下使用加锁的方式即每次只能有一个最新的版本；而对于 Read Committed 和 Repeatable Read 来说都必须读提交的事务修改过的记录，核心就是判断版本链中的哪个版本是当前事务可见的。为此出现了ReadView，其主要包括4个比较重要的内容：
```

1. m_ids：表示在生成 ReadView 时当前系统活跃的读写事务 trx_id 列表
2. min_trx_id：在生成 ReadView 时当前系统中活跃的读写事务中最小的事务ID，也就是 m_ids 最小值
3. max_trx_id：生成 ReadView 时系统中应该分配给下一个事务的ID值
4. creator_trx_id：生成该 ReadView 的事务id

有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见

- 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问
- 如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问
- 如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问
- 如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务**还是活跃**的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问

在MySQL中 READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是 **它们生成ReadView的时机不同。**

1. READ COMMITTED 读提交在事务内做读取操作时每次都生成一个 ReadView，这样它总是读到最新提交的（在 m_ids）内
2. REPEATABLE READ 不可重复读则是在一个事务内做查询，都是第一次读的 ReadView，这样它的提交数据就永远都是第一次生成的，也就不会有不可重复读的问题

**案例**

第一步：

**更新数据都是先读后写的，而且这个读只能读当前的值即当前读。**

所以这里的事务A如果也是 select ... for update

但如果实在 RC 读提交的隔离级别下，那么每次读都是要重新创建视图。此时事务B可读到C‘及B本身的值即K=3，但是事务A由于B还未提交所以读到的K=2

第二步：

事务C改成 [ start; update...; commit; ]

事务B更新数据只能用当前读如果当前的行锁被占用就要等待


