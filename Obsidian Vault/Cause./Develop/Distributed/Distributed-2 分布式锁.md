# 1、选型

-  **分布式锁要考虑的几点**

	1.  互斥性
	2.  可重入
	3.  锁性能
	4.  阻塞
	5.  避免死锁
	6.  可靠性
	7.  ...

### 1.1 数据库

-  **实现**

	通过 `key + desc` 唯一键作为约束，通过插入与删除作为加锁与解锁

-  **优劣势**

	优势：易于理解
	劣势：
	1.  数据库是单点：主备同步
	2.  没有失效时间：定时任务
	3.  非阻塞，的没能加锁的不会排队只能再次触发：while自旋
	4.  非重入的：表上加线程信息


### 1.2 Redis

-  **实现**
	1. `set nx (set if not exist)` ：Redis单线程机制 及 内存操作 保证互斥与性能
	2. `set px(set expire time)`：Lua原子脚本加锁
	   `jedis.set(lockKey, requestId, "NX", "PX"，expireTime)`

-  **优劣势**

	优势：SETNX命令简单，易于理解
	劣势：
	1.  锁续期问题：到期后但执行方法还没结束，会导致双重写
	2.  死锁问题：未设置过期时间，服务端奔溃，导致死锁
	3.  不支持重入问题：需要 redisson
	4.  单点故障问题

### 1.3 Redisson 

-  **实现**

	Redisson 是 Java 实现的客户端，

-  **优劣势**

	优势：
	1.  支持 Fair 和 NotFair
	2.  解决锁续期问题：利用看门狗延长有效期
	3.  解决单点问题：RedLock
	4.  解决不可重入


-  **RedLock方案**

	单点实例挂了 或者 master同步到slaver节点时master挂了，导致新选举的节点没加key
	
	![[image-Distributed-2 分布式锁-20240530200159971.png|600]]
	
	解决方案就是向多个节点发送 setnx 信息超过半数成功即认为加锁OK
	![[image-Distributed-2 分布式锁-20240530200334073.png|450]]
	
	存在的问题（不支持使用）
	1. 安全性和可靠性担忧：网络分区和网络故障的情况也不能保证完全互斥
	2. 维护和操作复杂
	3. 某些故障模式下不能提供正确服务：如主从复制下，主节点出现故障，选举新节点可能出现丢失
	
	解决方案
	1.  使用强一致性，如etcd、zk、consul
	2.  redis setnx + 单例：容忍服务故障（一般很难容忍吧... 几十分钟的不可用业务直接炸了）
	3.  redis setnx + 多例 + 业务自己幂等对账


## 1.4 Zookeeper

-  **方案**

	1.  加锁：在zookeeper上与该方法指定目录下生成一个瞬时节点
	2.  解锁：将瞬时节点删除

-  **优劣势**

	优势
	1.  强一致性：出现不可用节点，直接踢出管理
	2.  解决锁无法释放问题：瞬时节点一旦session会话结束，自动删除
	3.  解决单点问题：zk集群部署，只要半数以上存活，就可以对外服务
	4.  可重入
	5.  支持阻塞：创建顺序节点后，一旦节点变化通过监听器触发，自己是不是最小节点，是则获得锁
	劣势：
	1.  需要新增&删除节点，性能上没缓存好

# 2、方案

## Bond

- **方案**

	1、一期：Etcd 有序节点 + 监听器（考虑到强一致性、原生锁操作）
	2、二期：KVDS（考虑优先RT、非强一致、可重入性、非公平的阻塞性）

-  **CP or AP**

	允许特殊时期的不一致性，换取性能的大幅提升  [[Distributed-1  分布式基论·CAP]]

-  **阻塞**
	![[image-Distributed-2 分布式锁-20240530210301679.png]]


 - **可重入性**

	![[image-Distributed-2 分布式锁-20240530210614078.png|600]]
	
	ThreadLocal - 线程本地变量存储当前的状态，根据 lock key 判断是否为新调用，如果是则执行实际加锁请求，否则则重入计数器 +1 。解锁则重入计数器先 -1 ，再判断是否小于 0 ，是的话则执行真实的解锁请求


-  **网络超时 + 重试失败 + 查询**

	![[image-Distributed-1 分布式锁-20240418195457231.png|600]]

	简单来说就是在加锁超时后，再次去获取锁，如果获取到则说明加锁成功否则加锁失败

	不足
	 -> 网络原因超时 
	 -> 发起第二次加锁 
	 -> 第一次成功 
	 -> 第二次失败，就存在lease time没有任何线程拿到锁
	 
	 解决方案：二次加锁之前进行重入查询


-  **A加锁 + 自动超时 +B加锁 + A解锁**

	线程A到释放时间但业务逻辑还未执行完，同时过后执行释放锁命令，这时线程之间存在互相unlock的情况
	![[image-Distributed-2 分布式锁-20240530210548077.png]]


	- 发送 lock 请求之前记录时间点 `T`
	- 执行 unlock 操作的时候
	    1.  若当前时间 <= ( T + leaseTime - 150ms ) ，发送 unlock 请求。
	    2.  若当前时间 > ( T + leaseTime -150ms ) && 当前时间 < ( T + leaseTime ) ， 不执行任何操作
	    3.  若当前时间已经超时，则不发送 unlock 请求，且 告警 给对应的应用 owner 
	  (150ms 是给予 unlock 操作的缓冲时间段，即从发送请求开始到 server 执行unlock操作的时间段) 


[有赞 Bond 分布式锁](https://mp.weixin.qq.com/s/X7e0W5GCul3DrnuPu9aoUg)