怎么理解一致性？在分布式系统中，各个节点

## CAP再理解

-  **Consistence 一致性**

	对某个指定的客户端来说读操作保证能够返回最新的写操作结果


- **Availability 可用性**

	非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）

-  **Partition 可容错网络分区**

	当出现网络分区（丢包、连接中断、拥塞等原因）后系统能继续履行职责


```
理解 CAP 理论的最简单方式是想象两个节点分处分区两侧：
	1、允许至少一个节点更新状态会导致数据不一致，即丧失了 C 性质
	2、如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了 A 性质
	3、除非两个节点可以互相通信，才能既保证 C 又保证 A，这又会导致丧失 P 性质
	
一般来说跨区域的系统，设计师无法舍弃 P 性质，那么就只能在数据一致性和可用性上做一个艰难选择
（ 如果舍弃P意味着发生分区时候为了保证C，系统要禁止写入，但这又和A冲突 ）
```


![[image-Distributed-1  分布式基论CAP-20240417135150011.png]]![[image-Distributed-1  分布式基论CAP-20240417135201767.png]]

## CAP关键点

-  **什么是CAP**

	一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。

-  **关键点**

	 强调了两点：interconnected 和 share data （连接 和 分享）
	 为何要强调这两点呢？ 因为分布式系统并不一定会互联和共享数据。最简单的例如 Memcache 的集群，相互之间就没有连接和共享数据，因此 Memcache 集群这类分布式系统就不符合 CAP 理论探讨的对象；而 MySQL 集群就是互联和进行数据复制的，因此是 CAP 理论探讨的对象

- **强调点**

	强调了 write/read pair
	也就是说，CAP 关注的是对数据的读写操作，而不是分布式系统的所有功能。例如，ZooKeeper 的选举机制就不是 CAP 探讨的对象


## CAP的议论

-  **CAP关注的粒度是数据而不是整个系统**

	每个系统不可能只处理一种数据，而是包含多种类型，有的数据必须选择 CP，有的数据必须选择AP。
	以一个最简单的用户管理系统为例，用户管理系统包含用户账号数据（用户 ID、密码）、用户信息数据（昵称、兴趣、爱好、性别、自我介绍等）。通常情况下，用户账号数据会选择 CP，而用户信息数据会选择 AP


- **CAP 的 P（分区容错性）**

	关于 C vs A 的第一回合争论表现为 ACID 和 BASE 之争，提出 CAP 目的是证明有必要开拓更广阔的设计空间，因此才有了 ”三选二” 公式。但其有些误导性，主要表现为
	1.  分区很少发生，那么在系统不存在分区的情况下没什么理由牺牲 C 或 A
	2.  C 与 A 之间的取舍可以在同一系统内以非常小的粒度发生
	3.  3种性质都可以在程度上衡量，并不是非黑即白的。可用性也是0% 到 100%之间连续变化，一致性也分很多级别

- **CAP是忽略网络延迟**

	CAP理论的经典解释是忽略网络延迟的，但在实际中延迟和分区密切相关，是无法绝对保证的C一致性。
	
	那对于一致性严苛的业务场景，例如和金钱相关的用户余额，或者和抢购相关的商品库存，技术上是无法做到分布式场景下完美的一致性的。而业务上必须要求一致性，因此单个用户的余额、单个商品的库存，理论上要求选择 CP 而实际上 CP 都做不到，只能选择 CA。也就是说，只能单点写入，其他节点做备份，无法做到分布式情况下多点写入
	
	需要注意的是，这并不意味着这类系统无法应用分布式架构，只是说“单个用户余额、单个商品库存”无法做分布式，但系统整体还是可以应用分布式架构的。我们可以将用户 id 为 0 ~ 100 的数据存储在 Node 1，将用户 id 为 101 ~ 200 的数据存储在 Node 2，Client 根据用户 id 来决定访问哪个 Node。对于单个用户来说，读写操作都只能在某个节点上进行；对所有用户来说，有一部分用户的读写操作在 Node 1 上，有一部分用户的读写操作在 Node 2 上。
	
	这样的设计有一个很明显的问题就是某个节点故障时，这个节点上的用户就无法进行读写操作了，但站在整体上来看，这种设计可以降低节点故障时受影响的用户的数量和范围，毕竟只影响 20% 的用户肯定要比影响所有用户要好。这也是为什么挖掘机挖断光缆后，支付宝只有一部分用户会出现业务异常，而不是所有用户业务异常的原因


- **正常运行情况不存在CP和AP选择，可同时满足CA**

	CAP 理论告诉我们分布式系统只能选择 CP 或者 AP，但其实这里的前提是系统发生了“分区”现象。如果系统没有发生分区现象，也就是说 P 不存在的时候（节点间的网络连接一切正常），我们没有必要放弃 C 或者 A，应该 C 和 A 都可以保证，这就要求架构设计的时候既要考虑分区发生时选择 CP 还是 AP，也要考虑分区没有发生时如何保证 CA。
	
	同样以用户管理系统为例，即使是实现 CA，不同的数据实现方式也可能不一样：用户账号数据可以采用“消息队列”的方式来实现 CA，因为消息队列可以比较好地控制实时性，但实现起来就复杂一些；而用户信息数据可以采用“数据库同步”的方式来实现 CA，因为数据库的方式虽然在某些场景下可能延迟较高，但使用起来简单。



- **还是要为分区恢复做的准备**

```
	CAP 理论告诉我们三者只能取两个，需要“牺牲”（sacrificed）另外一个，这里的“牺牲”是有一定误导作用的，因为“牺牲”让很多人理解成什么都不做。实际上，CAP 理论的“牺牲”只是说在分区过程中我们无法保证 C 或者 A，但并不意味着什么都不做。因为在系统整个运行周期中，大部分时间都是正常的，发生分区现象的时间并不长。

	例如，99.99% 可用性（俗称 4 个 9）的系统，一年运行下来，不可用的时间只有 50 分钟；99.999%（俗称 5 个 9）可用性的系统，一年运行下来，不可用的时间只有 5 分钟。分区期间放弃 C 或者 A，并不意味着永远放弃 C 和 A，我们可以在分区期间进行一些操作，从而让分区故障解决后，系统能够重新达到 CA 的状态。最典型的就是在分区期间记录一些日志，当分区故障解决后，系统根据日志进行数据恢复，使得重新达到 CA 状态。

	同样以用户管理系统为例，对于用户账号数据，假设我们选择了 CP，则分区发生后，节点 1 可以继续注册新用户，节点 2 无法注册新用户（这里就是不符合 A 的原因，因为节点 2 收到注册请求后会返回 error），此时节点 1 可以将新注册但未同步到节点 2 的用户记录到日志中。当分区恢复后，节点 1 读取日志中的记录，同步给节点 2，当同步完成后，节点 1 和节点 2 就达到了同时满足 CA 的状态。而对于用户信息数据，假设我们选择了 AP，则分区发生后，节点 1 和节点 2 都可以修改用户信息，但两边可能修改不一样。例如，用户在节点 1 中将爱好改为“旅游、美食、跑步”，然后用户在节点 2 中将爱好改为“美食、游戏”，节点 1 和节点 2 都记录了未同步的爱好数据，当分区恢复后，系统按照某个规则来合并数据。例如，按照“最后修改优先规则”将用户爱好修改为“美食、游戏”，按照“字数最多优先规则”则将用户爱好修改为“旅游，美食、跑步”，也可以完全将数据冲突报告出来，由人工来选择具体应该采用哪一条。
```

https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed

## CAP  vs  ACID

-  **1、Atomicity（原子性）**

	一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。

-  **2、Consistency（一致性）**

	在事务开始之前和事务结束以后，数据库的完整性没有被破坏。

-  **3、Isolation（隔离性）**

	数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

-  **4、Durability（持久性）**

	事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

```
	可以看到，ACID 中的 A（Atomicity）和 CAP 中的 A（Availability）意义完全不同，而 ACID 中的 C 和 CAP 中的 C 名称虽然都是一致性，但含义也完全不一样。ACID 中的 C 是指数据库的数据完整性，而 CAP 中的 C 是指分布式节点中的数据一致性。再结合 ACID 的应用场景是数据库事务，CAP 关注的是分布式系统数据读写这个差异点来看，其实 CAP 和 ACID 的对比就类似关公战秦琼，虽然关公和秦琼都是武将，但其实没有太多可比性。
```


## CAP  vs  BASE

  ` ASE 是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency），核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。

 -  **基本可用（Basically Available）**
 
	  `布式系统在出现故障时，允许损失部分可用性，即保证核心可用

 - **软状态（Soft State）**
 
	`允许系统存在中间状态，而该中间状态不会影响系统整体可用性
	`（这里的中间状态就是 CAP 理论中的数据不一致）
 
 - **最终一致性（Eventual Consistency）** 
  
   `系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。

BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。前面在剖析 CAP 理论时，提到了其实和 BASE 相关的两点：CAP 理论是忽略延时的，而实际应用中延时是无法避免的。这一点就意味着完美的 CP 场景是不存在的，即使是几毫秒的数据复制延迟，在这几毫秒时间间隔内，系统是不符合 CP 要求的。因此 CAP 中的 CP 方案，实际上也是实现了最终一致性，只是“一定时间”是指几毫秒而已。AP 方案中牺牲一致性只是指分区期间，而不是永远放弃一致性。这一点其实就是 BASE 理论延伸的地方，分区期间牺牲一致性，但分区故障恢复后，系统应该达到最终一致性。