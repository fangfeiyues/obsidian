
## 解决方案

### 2PC

-  **过程**

	![[MQ-1 消息发送-1.png|500]]


-  **优势**


-  **缺陷**

	2PC看似能提供原子性操作，但存在严重缺陷
	
	1、协调者 and 参与者间的状态不一致（ 最致命的！！！ ）
		a)  第二阶段commit命令发送，参与者接受不到命令则会一直无法提交事务，造成的数据不一致 
		b) 第二阶段commit命令发送 -> 参与者 and 协调者都挂了 -> 协调者重新选举恢复并继续操作commit -> 参与者A恢复后执行操作commit -> 参与者B由于恢复晚且挂前执行rollback ???
	
	2、超时导致的同步问题。2PC中参与者节点都是事务阻塞型，当某一个节点出现通信超时，其余参与者都会被动无法释放
	
	3、 单点故障风险。 由于严重依赖协调者，一旦发生故障都还处于锁定资源状态

-  **案例**

	1.  MySQL redo log 和 bin log 两阶段提交，先 redo log 预提交，再 bin log 提交，成功后 redo log 提交
	2.  ... 

### 3PC

-  **过程**
  
	3PC在2PC的第一阶段和第二阶段中插入一个`准备阶段`，同时协调者引入`超时机制`
	
	1.  CanCommit：协调者向所有参与者发送 CanCommit 命令，是否可以执行
	2.  PreCommit：协调者向所有参与者发送 PreCommit 命令，锁定资源但不等待避免直接获取出现卡住
	3.  DoCommit：正式提交事务


-  **优势**

	解决两阶段的 同步阻塞 and 「**协调者挂了 + 参与者挂了 + 且参与者挂之前执行了操作**」场景。
	`通过prepare-commit阶段确定协调者状态，然后在协调者恢复了但参与者还挂着的情况下，定位到参与者本应执行的动作，再指导其他参与者执行。等参与者恢复后，继续执行，最终保证所有参与者的一致性

-  **不足**

	在`docommit`阶段，如果参与者无法及时收到来自协调者的`docommit`或`rebort`命令，会在等待超时之后，自动提交任务，如果有异常，就可能造成不一致

-  **案例**

	（班长通知大家聚会，先电话一一确认时间 --> 都可行就提前约好锁定 --> 当天再正式邀约）

### TCC

-  **过程**
	
	`TCC（Try-Confirm-Cancel）`补偿事务，其核心思想是针对每个操作都要注册一个与其对应的确认Try 和 补偿Cancel。与2PC相似
	-  Try：下单时通过Try操作扣除库存预留资源
	-  Confirm：确认执行业务操作，如果失败可重试解决避免引入更大复杂度
	-  Cancel：有一个业务方未成功，则协调者通知所有参与者回滚事务
	  
	![[MQ-1 消息发送-4.png|400]]
	
	如果 Confirm 或 Cancel 失败，常用的处理方式有：
	1.  重试。用的最多，因为已经try锁定资源那么大概率可以成功，如果失败直接cancel再失败复杂度更大
	2.  取消。如果重试还失败，则cancel撤销try阶段预留的资源
	3.  日志告警和监控。定位问题？
	4.  人工干预。

-  **vs 2PC**

	1.  实现机制不同：2PC使用协调者和参与者实现事务，TCC采用分阶段提交方式？
	2.  处理方式不同：2PC采用预写日志，在提交和回滚之间多次通信；TCC只需要在3个阶段执行相应逻辑
	3.  异常处理不同：2PC需要处理网络节点故障等，可能会导致整个事务无法提交或回滚；TCC只需要处理业务异常，相对简单
	4.  适用场景不同：2PC适用于对事务一致性要求高的如银行转账，而TCC要求没这么高如扣库存失败后允许重试

-  **优点**


-  **缺点**
	1.  应用侵入性强：每个业务方都要继承 try、confirm、cancel三个接口
	2.  开发难度大：代码量大，要保证数据一致性，confim 和 cancel 接口还必须幂等
	3.  空回滚：try的过程有的成功有的失败，都执行cancel的话，对于没有try的来说就是一次空操作
	4.  **悬挂事务**：try -> 超时 -> cancel，cancel完后try又来了导致资源无法释放
	   （后两者都可以用事务表记录状态来解决，看看try状态是否可以cancel）


### 本地消息表

-  **过程**

	--> 1-2、本地先落消息记录&业务数据操作
	--> 3、发送异步消息 
	--> 4-5、消费者执行成功 
	--> 6、回调生产者 
	--> 7、更新消息表状态，如果一定时间未回调，要主动查询
	![[image-Distributed-3 分布式事务-20240613230434468.png]]

-  **优点**

	1.  可靠性高
	2.  可扩展性号
	3.  适用范围广

-  **缺点**

	1.  实现复杂度高
	2.  系统性能受限，本地还要写数据
	3.  会带来消息扫表慢查

### Seata

-  **过程**

	支持4种模式： AT模式、TCC模式、Saga模式、 XA模式
	
	![[image-Distributed-3 分布式事务-20240613231607053.png|500]]


### Saga

-  **大意**

	通过`异步消息`来协调本地事务，将各个系统的接受到`异步消息`后处理结果给协调者，通过结果来判断是否继续向下或回滚。流程很简单但使用它们有一些挑战
	1.  Saga之间缺乏隔离？
	2.  发生错误时难回滚更改

- **协同式saga**
  
	Saga的决策和执行顺序逻辑分布在Saga的每一个参与方中，它们通过交换事件的方式来沟通。
	 这样会有一些弊端：
	1.  更难理解。没有单一的Saga编排
	2.  服务之间的循环依赖
	3.  紧耦合风险

- **编排式Saga**
  
	Saga每一个决策和顺序都集中在一个Saga编排器，通过编排器发出命令式消息给各个Saga参与方。

-  **隔离性问题**
  
	在事务的ACID中事务隔离性会带来一些问题，分布式环境下依旧也是如此
	1. 丢失更新。 一个Saga更新了另一个还未执行完Saga的某一个节点
	2. 脏读。 读到了另一个Saga没有执行完全的节点数据
	3. 不可重复读。一个Saga读到了两个结果
	   
	解决方案
	1. 语义锁 *_PEDING
	2. 版本文件
	3. 重读值。乐观锁的一种


## 落地案例
### RocketMQ
消息的目的是解耦但彻底的解耦又必然带来一致性的问题

![[MQ-1 消息发送.png|700]]

主要步骤如下：
1.  生产者发送 `Half` 不消费的消息（如发送失败，half -> unknow -> 删除）
2.  服务端 Broker 存储完成后，回写给生产者
3.  生产者调用回调方法 `TransactionListener` 执行本地方法
4.  本地执行的结果来决定 Broker 是 `Commit` 还是 `RollBack` 消息
5.  二次确认消息如果 Broker 没收到消息
6.  Producer 回调 Local 确认

### 本地消息表

![[MQ-1 消息发送-2.png]]

在这个过程中，可能几个步骤都发生失败，那失败了怎么办？
 -  1、2失败，因为在同一个事务中，所以会回滚
 -  3 失败，那么就需要有一个定时任务扫描消息数据，对未成功的消息再次投递
 -  4、5失败，则依靠消息重试机制
 -  6、7失败，相当于两个分布式系统的数据已经一致，但本地消息表还是错的。可以定时查询下有状态？？？（如果有很多下游不是累死？）


### Dubbo