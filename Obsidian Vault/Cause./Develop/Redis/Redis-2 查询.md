
## 数据结构

### SDS 

动态字符串不仅可以用于存储简单字符串，还可以用于实现复杂的列表list、哈希hash、集合set等，以及作为缓冲区buffer如AOF缓冲区以及客户端状态中的缓冲区。
##### 字符串长度
C字符串不记录自身的长度，所以获取必须遍历。但SDS有len属性，可以常数级
##### 缓冲区溢出
```shell
-- 在 s 后拼接字符串
sdscat(s, "Cluster")
```

在执行拼接前会检查 s 的长度是否足够，不足则会扩展 s 的空间
##### 堕性空间释放

当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用

### Linked

#### 使用
基础类型 List 列表用的 链表 结构

```shell
> lpush fruits apple banana 
> rpush fruits orange
> lpop fruits 
> rpop fruits
```

#### 构造
```c
typedef struct listNode {
   // 前置节点
   struct listNode * prev;
   // 后置节点
   struct listNode * next;
   // 节点的值
   void * value;
}
```

Redis的链表实现的特性可以总结如下：
-  双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)
-  无环：表头节点的 prev指针 和 表尾节点的 next指针 都指向NULL
-  带链表长度计数器：获取链表中节点数量的复杂度为O(1)
-  多态：可以用于保存各种不同类型的值

### Dict 

#### 使用
Redis的String字符串、Hash哈希以及一些高级的数据类型如Steams、Bitmap、HyperLogLog等

![[Redis-2 字典.png|500]]
#### 构造
字典使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

```c
// --- 字典 ---
typedef struct dict{
  // 类型特定函数
  dictType *type;
  // 私有数据
  void *privdata;
  // 哈希表，重要！！
  dictht ht[2];
  // rehash索引
  int trehashidx;
}

//  --- 哈希表 ---
typedef struct dictht {
   // 哈希表数组，指向 dictEntry 结构的键值对
   dictEntry **table;
   // 哈希表大小
   unsigned long size;
   // 哈希表大小掩码，用于极端索引值
   unsigned long sizemark;
   // 该哈希表已有节点的数量
   unsigned long used;
} dictht;

typedef struct dictEntry {
   // 键
   void *key;
   // 值：可以是一个指针、或者一个uint64_t整数等
   union{ ... }v;
   // 指向下个哈希表
   struct dictEntity *next;
} dictEntity;


```


![[Redis-2 字典.png]]
> 这里有4层指针，其实可以直接从 字典dict 链接到 键值dictEntity指针 即可，但为了渐变和统计还是加了层 dictht 

#### 哈希
当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。
- **哈希算法**
Redis 使用 MurmurHash2 算法来计算键的哈希值

- **哈希冲突**
被分配到同一个索引伤的多个节点可以用这个单向链表连接起来，解决键冲突问题
##### rehash重新散列
扩张 或 收缩到一个新的哈希表 `ht[1] = ht[0].used` 的 2的n次方，并释放老的哈希表

##### 渐进式 rehash
在如果直接操作 ht[0] --> ht[1] ，会导致服务在一段时间内的不可用，为了减少影响通过多次、渐进的慢慢rehash到ht[1]，具体操作如下
1.  为 ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表
2.  在字典中维持一个索引计数器变量 rehashidx，并将它的值设置为0，表示 rehash 工作正式开始
3.  在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，程序出了执行指定操作外，还会顺带将 ht[0] 哈希表在 rehashidx 索引伤的所有键值对 rehash 到 ht[1]，当工作完成后程序将rehashidx 增1 
4.  所有键值都被 rehash 到 ht[1] 后程序将 rehashidx 设置为-1，表示操作完成


### ZSkipList 

跳表的优势是能支持平均 O(logN) 复杂度的节点查找，支持高效的范围查询
跳表首先是链表，但与传统链表相比有几点差异：
1.  元素按照升序排列存储，跳表结构中会包含排序所需的值
2.  前向节点可能包含多个指针，指针跨度不同

#### 使用
有序集合，支持以下能力
1.  查询有序范围

```shell
redis> ZADD fruits-price 5 'banana' 6.5 'cherry'
> ZRANGE fruits-price 0 2 WITHSCORES
> banana
> 5
> cherry
> 6.5

```

#### 构造
Redis 的跳跃表由 `zskiplistNode` 和 `zskiplist` 两个结构定义，其中 `zskiplistNode` 结构用于表示 **跳跃表节点**，而 `zskiplist` 用于保存跳跃表节点的相关信息如节点的数量以及指向表头节点和表尾节点指针等

![[Redis-2 查询.png|600]]

表节点信息 `zskiplist` 有
1.  header：指向跳跃表的表头节点
2.  tail：指向跳跃表的表尾节点
3.  level：记录跳跃表内最大节点的层数
4.  length：记录跳跃表的长度

跳跃表`zskiplistNode` 有
1.  level：层，每层有两个属性 
	1.  前进指针
	2.  跨度：跨度越大距离越远
2.  backward：后退指针
3.  score：分值，跳跃表所有节点都按分值从小到大排序
4.  obj：成员对象 ，是个指针，指向一个字符串对象

![[Redis-2 查询-1.png]]

##### 层数的设置
跳表的相邻两层的节点数量最理想比例是 2:1 ，查找复杂度可以降低到 O(logN)
Redis的做法是，跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于0.25（相当于概率25%），那么层数就增加1层，然后继续生成下一个随机数

#### vs 红黑树

1.  内存占用来说，跳表更灵活。平衡树每个节点2个指针，跳表每个节点为25%即1.25
2.  范围查找上，跳表更有优势
3.  算法实现难度，跳表更简单


### InSet

当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现
```shell
redis> SADD numbers 1 3 5 7 9

```

整数集合的底层实现是数组，这个数组以有序、无重复的方式保存集合元素

### Ziplist

压缩列表（ziplist）是当元素比较少时，Redis会采用Ziplist或ListPack（Redis 7.0替换成了ListPack）

### listpack

紧凑列表

### Object

![[Redis-2 查询-2.png|600]]

Q：Redis为什么这么快？

	 1、基于内存：Redis是一种基于内存的数据库，数据存储在内存中，读写速度非常快
	 2、单线程模型：Redis单线程模型意味着所有操作都是在一个线程内完成，不需要线程切换和上下文切换
	 3、多路复用I/O模型：Redis在单线程基础上，采用I/O多路复用技术，实现单个线程处理多个客户端连接能力
	 4、多线程的引入：Redis 6.0采用多线程技术，使得网络处理的请求并发进行

![[Redis-2 查询-3.png|600]]


---
## 数据类型

### Zset

Redis 在 ZSet有序集合 实现中有多种数据结构，大类的话有两种 `ziplist压缩列表（或listpack紧凑列表）` 和 `skiplist跳表`，当ZSet元素较少时候会采用 `ZipList` 来连续存储节省空间，当元素增多就会自动转换为 `SkipList` 。


---
# Q&A

Q：Redis为什么被设计成是单线程的？

	首先的单线程是指 “其网络IO和键值对读写是由一个线程完成”，也就是说，Redis中只有 网络请求模块 和 数据模块 操作是单线程，其他如持久化存储模块、集群支撑模块等是多线程的。

Q：多线程适用场景？

	一个计算机程序在执行过程中，主要进行两种操作：读写操作 和 计算操作。而多线程的目的是通过并发来提升I/O利用率 和 CPU利用率，但Redis是基于 内存操作 的CPU并不是其瓶颈，即使作为一个I/O密集框架有大量网络I/O和磁盘I/O发生，也有其他路子如I/O多路复用


Q：Redis为什么没在网络请求和数据模块使用多线程?

	1、Redis基于内存操作，绝大数瓶颈不在CPU，主要受限于内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。
	2、单线程模型可维护性更高、开发成本更低，避免了线程之间切换带来的开销。例如多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗
	3、单线程中使用多路复用I/O技术也能提升Redis的I/O复用率，处理性能非常高


Q：Redis6.0为什么要引入多线程呢？

	Redis自身角度来说，因为读写网络的read/write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:
	1、提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式
	2、使用多线程充分利用多核，典型的实现比如 Memcached
	所以Redis多线程只是用来处理网络请求，对于读写命令仍然用的单线程
	
	附：分布式架构中对数据进行分区并采用多个服务器？
	要管理的Redis服务器太多，维护代价大；某些适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂等等。
	
![[Redis-2 查询-4.png|500]]

Q：Redis6.0默认是否开启了多线程？

	Redis6.0的多线程默认是禁用的，只使用主线程。如需开启需要修改redis.conf配置文件：io-threads-do-reads = yes

Q：Redis6.0多线程开启时，线程数如何设置？

	开启多线程后，还需要设置线程数，否则是不生效的。同样修改redis.conf配置文件 io-threads4
	关于线程数的设置，官方有一个建议：4核的机器建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数。还需要注意的是，线程数并不是越大越好，官方认为超过了8个基本就没什么意义了。

Q：Redis6.0多线程的实现机制？

	核心思路是，将主线程的IO读写任务拆分出来给一组独立的线程执行，使得多个 socket 的读写可以并行化
	- 主线程负责接收建立连接的请求,获取socket放到全局等待处理队列
	- 主线程处理完读事件之后,通过Round Robin将这些连接分配给IO线程(并不会等待队列满)
	- 主线程阻塞等待IO线程读取socket完毕
	- 主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行
	- 主线程阻塞等待IO线程将数据回写socket完毕
	- 解除绑定,清空等待队列
	该线程有如下特点:
	- IO线程要么同时在读socket，要么同时在写，不会同时读或写
	- IO线程只负责读写socket解析命令，不负责命令处理（主线程串行执行命令）

Q：开启多线程后，是否会存在线程并发安全问题？

	Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行，因此不存在线程的并发安全问题
