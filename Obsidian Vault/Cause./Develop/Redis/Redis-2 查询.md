## 2.1 线程模型

### 2.11 单线程模型

-  **单线程模型**

	单线程是指 `网络IO 和 键值对读写` 是由一个线程完成，主要Redis的操作基本都是基于内存，CPU资源不是Redis的性能瓶颈
	
	其他如持久化存储模块、集群支撑模块等是多线程的，目的是通过并发来提升I/O利用率和CPU使用率

-  **网络请求 和 数据模块 -> 单线程**

	1、Redis基于内存操作，绝大数瓶颈不在CPU，主要受限于内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。
	
	2、单线程模型可维护性更高、开发成本更低，避免了线程之间切换带来的开销。例如多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗
	
	3、单线程中使用多路复用I/O技术也能提升Redis的I/O复用率，处理性能非常高

### 2.12 多线程模型

-  **多线程适用场景**

	计算机程序主要进行两种操作：`读写操作` 和 `计算操作`，对应的就是 `I/O利用率` 和 `CPU利用率`
	1. Redis 是基于`内存操作` ，所以 CPU 不是其瓶颈
	2. Redis 是 `I/O密集框架`，有大量网络I/O 和 磁盘I/O发生但也有其他路子，如 I/O多路复用

-  **Redis 6.0  -> 多线程**

	`所以Redis 6.0 多线程只是用来处理网络请求，对于读写命令仍然用的单线程`

-  **Redis 6.0  +  多线程 ？**

	访问数据TR角度来说，内存反应时间100ms、支持的QPS能 到 8000~10000，完全够用。但对于上亿交易量还是少了，但某些数据不适用于集群、分区也无法解决热点问题、数据偏斜等更加复杂。
	
	所以还是采用多线程方式进一步提升IO性能
	
	`io-threads-do-reads = yes` 默认禁用的，只使用主线程 

-   **Redis6.0多线程的实现机制**

	核心思路是将主线程IO读写任务拆分出来给一组独立的线程执行，使得多个socke 的读写可以并行化
	- 主线程负责接收建立连接的请求,获取socket放到全局等待处理队列
	- 主线程处理完读事件之后,通过Round Robin将这些连接分配给IO线程(并不会等待队列满)
	- 主线程阻塞等待IO线程读取socket完毕
	- 主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行
	- 主线程阻塞等待IO线程将数据回写socket完毕
	- 解除绑定,清空等待队列
	
	该线程有如下特点:
	- IO线程要么同时在读socket，要么同时在写，不会同时读或写
	- IO线程只负责读写socket解析命令，不负责命令处理（主线程串行执行命令）
	  
	  Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行，因此不存在线程的并发安全问题

## 2.2 数据类型

### 2.21 Sorted Set 有序集合

-  **使用**

```shell
redis> ZADD fruits-price 5 'banana' 6.5 'cherry'
> ZRANGE fruits-price 0 2 WITHSCORES
> banana
> 5
> cherry
> 6.5
```


-  **数据结构**

	`zset` 也称为 sorted set 是Redis中一种特殊的数据结构，它内部维护了一个有序的字典，这个字典的元素既包括一个成员member，也包括一个double类型的分值score，这个结构可以帮用户实现积分类型的排行榜数据、还有滑动窗口数据等
	
	当数据元素比较少时，Redis会采用 `zipList`（紧凑列表） 来存储，当增多后会自动转换为 `skipList`

### 2.22 String 字符串


### 2.23 Hash 哈希


### 2.24 List 列表

-  **使用**

```shell
> lpush fruits apple banana 
> rpush fruits orange
> lpop fruits 
> rpop fruits
```

### 2.25 Set 集合


### 2.26 Stream 流

-  **使用**

	Redis Stream 是 Redis 5.0 新增的数据结构，主要用于处理有序的、可追溯的消息流

-  **数据结构**

	Stream数据结构可视为一个日志或消息队列，并且按照添加的顺序进行排序，还支持消费者组。同事提供了消息持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，持久化保证不丢失。

## 数据结构

### sds 

-  **用法**

	动态字符串不仅可以用于存储简单字符串，还可以用于实现复杂的列表list、哈希hash、集合set等，以及作为缓冲区buffer如AOF缓冲区以及客户端状态中的缓冲区


-  **字符串长度**

	C字符串不记录自身的长度，所以获取必须遍历。但SDS有len属性，可以常数级
	

 -  **缓冲区溢出**
 
```shell
-- 在 s 后拼接字符串
sdscat(s, "Cluster")
```

	在执行拼接前会检查 s 的长度是否足够，不足则会扩展 s 的空间


-   **堕性空间释放**

	当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用

### linked

#### 使用
基础类型 List 列表用的 链表 结构

#### 构造
```c
typedef struct listNode {
   // 前置节点
   struct listNode * prev;
   // 后置节点
   struct listNode * next;
   // 节点的值
   void * value;
}
```

Redis的链表实现的特性可以总结如下：
-  双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)
-  无环：表头节点的 prev指针 和 表尾节点的 next指针 都指向NULL
-  带链表长度计数器：获取链表中节点数量的复杂度为O(1)
-  多态：可以用于保存各种不同类型的值

### dict 

#### 使用
Redis的String字符串、Hash哈希以及一些高级的数据类型如Steams、Bitmap、HyperLogLog等

![[Redis-2 字典.png|500]]
#### 构造
字典使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

```c
// --- 字典 ---
typedef struct dict{
  // 类型特定函数
  dictType *type;
  // 私有数据
  void *privdata;
  // 哈希表，重要！！
  dictht ht[2];
  // rehash索引
  int trehashidx;
}

//  --- 哈希表 ---
typedef struct dictht {
   // 哈希表数组，指向 dictEntry 结构的键值对
   dictEntry **table;
   // 哈希表大小
   unsigned long size;
   // 哈希表大小掩码，用于极端索引值
   unsigned long sizemark;
   // 该哈希表已有节点的数量
   unsigned long used;
} dictht;

typedef struct dictEntry {
   // 键
   void *key;
   // 值：可以是一个指针、或者一个uint64_t整数等
   union{ ... }v;
   // 指向下个哈希表
   struct dictEntity *next;
} dictEntity;


```


![[Redis-2 字典.png]]
> 这里有4层指针，其实可以直接从 字典dict 链接到 键值dictEntity指针 即可，但为了渐变和统计还是加了层 dictht 

#### 哈希
当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。
- **哈希算法**
Redis 使用 MurmurHash2 算法来计算键的哈希值

- **哈希冲突**
被分配到同一个索引伤的多个节点可以用这个单向链表连接起来，解决键冲突问题
##### rehash重新散列
扩张 或 收缩到一个新的哈希表 `ht[1] = ht[0].used` 的 2的n次方，并释放老的哈希表

##### 渐进式 rehash
在如果直接操作 ht[0] --> ht[1] ，会导致服务在一段时间内的不可用，为了减少影响通过多次、渐进的慢慢rehash到ht[1]，具体操作如下
1.  为 ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表
2.  在字典中维持一个索引计数器变量 rehashidx，并将它的值设置为0，表示 rehash 工作正式开始
3.  在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，程序出了执行指定操作外，还会顺带将 ht[0] 哈希表在 rehashidx 索引伤的所有键值对 rehash 到 ht[1]，当工作完成后程序将rehashidx 增1 
4.  所有键值都被 rehash 到 ht[1] 后程序将 rehashidx 设置为-1，表示操作完成


### zskipList 

#### 是什么

-  **优势**

	1.  能支持  O(logN) 复杂度的节点查找
	2.  支持高效的 score 范围查询

-  **数据结构**

	跳表首先是链表，但与传统链表相比有几点差异：
	1.  元素按照升序排列存储，跳表结构中会包含排序所需的值
	2.  前向节点可能包含多个指针，指针跨度不同

#### 怎么做

Redis zset 由跳跃表由 `zskiplistNode` 和 `zskiplist` 两个结构定义，
1. `zskiplistNode` 结构用于表示跳跃表节点
2. `zskiplist` 用于保存跳跃表节点的相关信息如节点的数量以及指向表头节点和表尾节点指针等

![[Redis-2 查询.png|600]]

-  **`zskiplist`**
	1.  header：指向跳跃表的表头节点
	2.  tail：指向跳跃表的表尾节点
	3.  level：记录跳跃表内最大节点的层数
	4.  length：记录跳跃表的长度

-  **`zskiplistNode`** 
	1.  level：层，每层有两个属性 
		1.  前进指针
		2.  跨度：跨度越大距离越远
	2.  backward：后退指针
	3.  score：分值，跳跃表所有节点都按分值从小到大排序
	4.  obj：成员对象 ，是个指针，指向一个字符串对象

-  **`level`**

	跳表的相邻两层的节点数量最理想比例是 2:1 ，查找复杂度可以降低到 O(logN)
	
	Redis的做法是，跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于0.25（相当于概率25%），那么层数就增加1层，然后继续生成下一个随机数

- **vs 红黑树** 

	1.  内存占用来说，跳表更灵活。平衡树每个节点2个指针，跳表每个节点为25%，即1.25
	2.  **范围查找上，跳表更有优势**
	3.  算法实现难度，跳表更简单


![[Redis-2 查询-1.png]]


### InSet

当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现
```shell
redis> SADD numbers 1 3 5 7 9

```

整数集合的底层实现是数组，这个数组以有序、无重复的方式保存集合元素

### Ziplist

压缩列表（ziplist）是当元素比较少时，Redis 会采用 Ziplist 或 ListPack（Redis 7.0替换成了ListPack）

### listpack

紧凑列表

### Object

![[Redis-2 查询-2.png|600]]

Q：Redis为什么这么快？

	 1、基于内存：Redis是一种基于内存的数据库，数据存储在内存中，读写速度非常快
	 2、单线程模型：Redis单线程模型意味着所有操作都是在一个线程内完成，不需要线程切换和上下文切换
	 3、多路复用I/O模型：Redis在单线程基础上，采用I/O多路复用技术，实现单个线程处理多个客户端连接能力
	 4、多线程的引入：Redis 6.0采用多线程技术，使得网络处理的请求并发进行

![[Redis-2 查询-3.png|600]]



