
-  **Redis is AP or CP?**

	**AP** 。Redis设计的目标是*高性能、高可扩展和高可复用性*，Redis的一致性模型是最终一致性，没法保证强一致性的原因是它分布式设计采用的是异步复制，导致节点之间存在的数据同步延迟和不一致的可能
	[[Distributed-1  分布式基论·CAP]]


Redis集群同步的3种方式：主从、哨兵、cluster

## 3.1  主从同步

Redis 的复制功能分为`同步(sync)` 和 `命令传播(command propagate) `
-  `同步操作` ：用于从服务器的数据库状态 --> 主服务器当前所处的数据库状态
-  `命令传播` ：用于在主服务器的数据库状态被修改，导致主从服务器不一致时，让主从回到一致

### 同步

-  **旧版同步**

	简单总结旧版的 `SYNC命令` 是一个非常耗费资源的操作（ Redis 2.8前 ）
	-  主服务器 需要执行`BGSAVE` 命令来生成 `RDB文件`，这个操作会耗费主服务器大量的 **CPU、内存 和 磁盘I/O**
	-  主服务器 需要将自己生成的 RDB文件 发送给 从服务器，也会耗费大量的网络资源，并对主服务器响应命令请求时间产生影响
	-  从服务器 接收到 RDB 文件 需要载入，并在载入期间从服务器会因为 阻塞 而不能处理命令请求
	  
	  ![[Redis-3 分布式.png|500]]


-  **新版同步**

	Redis 从 2.8版本 开始使用 `PSYNC命令` 代替 `SYNC命令` 来执行复制时同步
	`PSYNC命令`具有 `完整重同步(full resynchronization) ` 和 `部分重同步(partial resynchronization)`


-  *部分重同步*

	主要由三个部分构成：

	1、`复制偏移量 replication offset`
		执行复制的双方主从服务器分别会维护一个 复制偏移量 以来决定开始复制的位置
			1、主服务器每次向从服务器传播N个字节数据，就将自己的复制偏移值加上N
			2、从服务器每次收到主传来的N个字节数据，也将自己的复制偏移量值加上N
		![[Redis-3 集群-部分重同步-复制偏移量.png|400]]

	2、`复制积压缓冲区 repl_backing_buffer`
		是主服务器维护的一个固定长度先进先出队列，默认大小为1MB。保存着最近传播的写入命令，并且会为队列每个字节记录相应的复制偏移量，以决定是部分同步还是全量同步
		1.  如果 offset 偏移量之后的数据还在复制缓冲区，那么对从服务器执行部分重同步
		2.  如果 offset 偏移量不在缓冲区，那么还是执行完整重同步
		   
	  `repl_backlog_buffer`：它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量复制带来的性能开销。如果从库断开时间太久，repl_backlog_buffer 环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量复制，所以 **repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量复制的概率**。而在 repl_backlog_buffer 中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。
		
	  `replication buffer`：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer 中的数据发到 client socket 中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个 client，也会分配一个 buffer，只不过这个 buffer 专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer。


	3、`服务器运行ID`
	主服务器 根据 来同步的从服务器ID 决定之前是否同步过


### 复制实现

-  **步骤1：设置主服务器的地址和端口**

	 SLAVEOF 是个异步命令
	  > SLAVEOF 127.0.0.1 6379


-  **步骤2：建立套接字连接**

	1.  从服务器为这个套接字关联一个专门用于处理复制工作的文件处理器，复制后续接收RDB文件、写命令等
	-  主服务器在接受accept从服务器套接字后，会将从服务器做为一个客户端看待

	![[Redis-3 集群.png|400]]


-  **步骤3：发送PING命令**

	PING命令作用：检查 套接字读写状态 和 主服务器 双方是否正常工作
	PING命令后会有3种情况
	-  如果 主->从 但从不能在规定时间内读取内容，则从状态不佳，断开并重新创建套接字
	-  如果 主->从 返回一个错误，则主表示无法处理服务，断开并重新创建套接字
	-  如果 从 读取到 “PONG” 回复，则连接正常


-  **步骤4：身份验证**

	![[Redis-3 集群-1.png|400]]


-  **步骤5：发送端口信息**

	从服务器执行命令 REPLCONF listening-port < port-number >，向 主服务器 发送 从服务器的监听端口号


-  **步骤6：同步**

	从 向 主 发送 PSYNC 命令，并将自己的数据库更新至主服务器当前所处的状态。


-  **步骤7：命令传播**

	主 只要一直将自己执行的写命令发送给从即可，就可以保证主从一致


### 心跳检测

-  **发送命令**

	从 会以每秒一次的频率，向主发送命令
	REPLCONF ACK < replication_offset >

-  **连接状态**

	如果超过一秒钟没有收到从发来的 ACK 命令，那么主就知道主从之间出现连接问题了

-  **min-slaves命令**

	 `min-slaves-to-write` 和 `min-slaves-max-lag` 可以防止从在 服务器数量少于3个  或  3个从的延迟lag都大于等于10，主拒绝执行写命令


-  **命令丢失**
	
	如果主在从回传的命令中发现当前从的复制偏移量少于自己的，主会根据从提交的复制偏移，在复制积压缓冲区找到从缺少数据，重新发给从

## 3.2 Sentinel 哨兵

	Sentinel 哨兵是 Redis 的高可用性解决方案：由一个或多个Sentinel组成的系统可以监视任意多个主服务器，以及这些主下属的从，并在被监视的主下线时自动将下线主属下的某个从升级为新的主。

### 获取主从服务器信息

Sentinel 默认会以每十秒一次的频率，通过命令连接向被监视的主发送 INFO 命令获取主当前信息
-  主本身的信息，包括 run_id 域记录的服务器运行ID，以及 role 域记录的服务器角色
-  主下属所有从信息，每个从由 “slave” 字符串开头的行记录

### 检测主观下线状态

默认情况下Sentinel 会以每秒一次的频率向所有与它创建命令连接的实例如主、从、其他Sentinel等发送 PING命令，并通过PING回复来判断实例是否在线，配置 `down-after-millseconds = 50000ms` 那么当 master 连续 50000毫秒 返回无效回复时，Sentinel 就会将 master 标记为主观下线

### 检测客观下线状态

当Sentinel将一个主判断为主观下线后，为了确认是否真的下线它会同样向其他Sentinel询问，如果接受的数量足够多，Sentinel就会判断为客观下线并对主进行故障转移

### 选举领头Sentinel

Sentinel 设置局部零头的规则是 **先到先得**：最先向目标 Sentinel 发送 `is-master-down-by-addr`设置要求的，而之后接受到所有设置都会被目标 Sentinel 拒绝。得到半数以上的Sentinel将成为领头，否则将再次选举，就是一个 `Raft选举算法` （详见： [[Distributed-4 分布式一致性算法#Raft]]）

### 故障转移

-  **Step1：选出新的主服务器**

	SLAVEOF no one 将选中的从服务器转换为主服务器。（新的主数据不完备怎么办？）

-  **Step2：修改从服务器的复制目标**

-  **Step3：将旧的主变为从服务器**


## 3.3 Cluster 集群

Redis Cluster 是 Redis 推荐的分布式解决方案，它将数据自动分片到多个节点，每个节点负责一部分

Redis Cluster 采用主从复制来提高可用性，每个分片都有一个主节点和多个从节点，主节点负责写从节点负责复制数据并处理读请求

Redis Cluster 能自动检测节点故障，可标记不可用 或 从升主等

![[Redis-3 集群-2.png|600]]


### 数据分片

Redis的Cluster集群模式中，使用哈希槽（hash slot）方式来进行数据分片，先将整个数据集划分为多个槽，每个槽分配一个节点

![[image-Redis-3 集群-20240605005202697.png|600]]

整个数据集划分为 16384 (= 2^14) 个槽，集群每个节点可以划分多个槽