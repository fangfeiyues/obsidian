
## 1、缓存失效

	在很多场景，缓存到期失效后，会把查询的压力直接透传到DB

### 缓存穿透（缓存没，DB没）

-  **来源**

	指缓存和数据库中都没有的数据，而用户不断发起请求。
	
	由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义

-  方案

	1、将key-value对写为 key-null。缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
	
	2、布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小
	
	3、加强接口参数异常校验


### 缓存穿击（单条缓存没，DB有）

-  **解释**

	指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时如果并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。

 - **方案**

	1、 定时更新缓存，如缓存60分钟，那么在59分的时候自动更新
	
	2、加互斥锁，当获取到的缓存数据为空时候先加锁，再去查询数据库，加载完毕后释放
	
	3、接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制
	

### 缓存雪崩（多条缓存没，DB有）

- **解释**

	指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库

-  **解决方案**
 
	1、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
	
	2、如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
	

### 缓存污染

-  **解释**

	缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。
	
	缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。



Q：Redis性能问题有哪些，如何分析定位？

-  慢日志，慢查询就会导致后面的请求发生排队，客户端查询响应也会延迟
-  bigkey大对象
-  集中过期
	-  1、集中过期key加上一个随机时间，把集中过期时间打散降低过期清理压力
	-  2、Redis 4.0以上开启 lazy-free 机制，当删除过期key时把释放内存操作到后台操作
-  fork耗时严重
  




## 2、缓存一致性

### 缓存和数据库不一致

-  **更新数据库，再删除缓存**

	能解决大部分问题，
	1、如果缓存删除失败，可能导致不一致

-  **删除缓存，再更新数据库，再删除缓存**


-  **更新数据库，基于binlog监听删除缓存**

	同一，但binlog异步能力有助于延迟并发