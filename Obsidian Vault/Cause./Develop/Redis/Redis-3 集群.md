# Sync 同步

Redis 的复制功能分为 同步(sync) 和 命令传播(command propagate) 
-  同步操作 用于将 从服务器的数据库状态 更新至 主服务器当前所处的数据库状态
-  命令传播 则用于在主服务器的数据库状态被修改，导致主从服务器不一致时，让主从回到一致

## 同步

![[Redis-3 分布式.png|400]]
### 旧版同步

简单总结旧版的 `SYNC命令` 是一个非常耗费资源的操作（ Redis 2.8前 ）
-  主服务器 需要执行`BGSAVE` 命令来生成 `RDB文件`，这个操作会耗费主服务器大量的 **CPU、内存 和 磁盘I/O**
-  主服务器 需要将自己生成的 RDB文件 发送给 从服务器，也会耗费大量的网络资源，并对主服务器响应命令请求时间产生影响
-  从服务器 接收到 RDB 文件 需要载入，并在载入期间从服务器会因为 阻塞 而不能处理命令请求


### 新版同步

Redis 从 2.8版本 开始使用 PSYNC命令 代替 SYNC命令 来执行复制时同步。PSYNC命令具有 完整重同步( full resynchronization ) 和 部分重同步( partial resynchronization )

#### 部分重同步

主要由三个部分构成
##### 复制偏移量 replication offset
执行复制的双方主从服务器分别会维护一个 复制偏移量 以来决定开始复制的位置
-  主服务器每次向从服务器传播N个字节数据，就将自己的复制偏移值加上N
-  从服务器每次收到主传来的N个字节数据，也将自己的复制偏移量值加上N

![[Redis-3 集群-部分重同步-复制偏移量.png|400]]

#### 复制积压缓冲区
是主服务器维护的一个固定长度先进先出队列，默认大小为1MB。保存着最近传播的写入命令，并且会为队列每个字节记录相应的复制偏移量，以决定是部分同步还是全量同步
1.  如果 offset 偏移量之后的数据还在复制缓冲区，那么对从服务器执行部分重同步
2.  如果 offset 偏移量不在缓冲区，那么还是执行完整重同步


#### 服务器运行ID
主服务器 根据 来同步的从服务器ID 决定之前是否同步过


## 复制实现

#### 步骤1：设置主服务器的地址和端口

```shell
127.0.0.1:12345> SLAVEOF 127.0.0.1 6379
OK
```

SLAVEOF 是个异步命令

#### 步骤2：建立套接字连接

-  从服务器会为这个套接字关联一个专门用于处理复制工作的文件处理器，复制后续接收RDB文件、写命令等
-  主服务器在接受accept从服务器套接字后，会将从服务器做为一个客户端看待

![[Redis-3 集群.png|400]]


#### 步骤3：发送PING命令
PING命令作用：检查 套接字读写状态 和 主服务器 双方是否正常工作
PING命令后会有3种情况
-  如果 主->从 但从不能在规定时间内读取内容，则从状态不佳，断开并重新创建套接字
-  如果 主->从 返回一个错误，则主表示无法处理服务，断开并重新创建套接字
-  如果 从 读取到 “PONG” 回复，则连接正常

#### 步骤4：身份验证

![[Redis-3 集群-1.png|400]]


#### 步骤5：发送端口信息

从服务器执行命令 REPLCONF listening-port < port-number >，向 主服务器 发送 从服务器的监听端口号

#### 步骤6：同步
从 向 主 发送 PSYNC 命令，并将自己的数据库更新至主服务器当前所处的状态。

#### 步骤7：命令传播
主 只要一直将自己执行的写命令发送给从即可，就可以保证主从一致


## 心跳检测

从 会以每秒一次的频率，向主发送命令：
```shell
REPLCONF ACK < replication_offset >
```

### 检测主从间的网络连接状态

如果超过一秒钟没有收到从发来的 ACK 命令，那么主就知道主从之间出现连接问题了

### 辅助实现 min-slaves

Redis 的 `min-slaves-to-write` 和 `min-slaves-max-lag` 可以防止从在 ***服务器数量少于3个***  或  ***3个从的延迟lag都大于等于10***，主拒绝执行写命令


### 检测命令丢失

如果主在从回传的命令中发现当前从的复制偏移量少于自己的，主会根据从提交的复制偏移，在复制积压缓冲区找到从缺少数据，重新发给从。

# Sentinel 哨兵

Sentinel 哨兵是 Redis 的高可用性解决方案：由一个或多个Sentinel组成的系统可以监视任意多个主服务器，以及这些主下属的从，并在被监视的主下线时自动将下线主属下的某个从升级为新的主。

## 获取主从服务器信息

Sentinel 默认会以每十秒一次的频率，通过命令连接向被监视的主发送 INFO 命令获取主当前信息
-  主本身的信息，包括 run_id 域记录的服务器运行ID，以及 role 域记录的服务器角色
-  主下属所有从信息，每个从由 “slave” 字符串开头的行记录

## 检测主观下线状态

默认情况下Sentinel 会以每秒一次的频率向所有与它创建命令连接的实例如主、从、其他Sentinel等发送 PING命令，并通过PING回复来判断实例是否在线
配置 `down-after-millseconds = 50000ms` 那么当 主master 连续 50000毫秒 返回无效回复时，Sentinel 就会将 master 标记为主观下线

## 检测客观下线状态

当Sentinel将一个主判断为主观下线后，为了确认是否真的下线它会同样向其他Sentinel询问，如果接受的数量足够多，Sentinel就会判断为客观下线并对主进行故障转移


## 选举领头Sentinel

Sentinel 设置局部零头的规则是先到先得：最先向目标Sentinel发送 is-master-down-by-addr 设置要求的，而之后接受到所有设置都会被目标Sentinel拒绝。得到半数以上的Sentinel将成为领头。否则将再次选举（ 具体算法？？？ ）


## 故障转移

### Step1：选出新的主服务器

SLAVEOF no one 将选中的从服务器转换为主服务器。（新的主数据不完备怎么办？）

### Step2：修改从服务器的复制目标


### Step3：将旧的主变为从服务器



# Cluster 集群

