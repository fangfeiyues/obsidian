# Sync 同步

Redis 的复制功能分为 同步(sync) 和 命令传播(command propagate) 
-  同步操作 用于将 从服务器的数据库状态 更新至 主服务器当前所处的数据库状态
-  命令传播 则用于在主服务器的数据库状态被修改，导致主从服务器不一致时，让主从回到一致

## 同步

![[Redis-3 分布式.png|400]]
### 旧版同步

简单总结旧版的 `SYNC命令` 是一个非常耗费资源的操作（ Redis 2.8前 ）
-  主服务器 需要执行`BGSAVE` 命令来生成 `RDB文件`，这个操作会耗费主服务器大量的 **CPU、内存 和 磁盘I/O**
-  主服务器 需要将自己生成的 RDB文件 发送给 从服务器，也会耗费大量的网络资源，并对主服务器响应命令请求时间产生影响
-  从服务器 接收到 RDB 文件 需要载入，并在载入期间从服务器会因为 阻塞 而不能处理命令请求


### 新版同步

Redis 从 2.8版本 开始使用 `PSYNC命令` 代替 `SYNC命令` 来执行复制时同步。
`PSYNC命令`具有 `完整重同步( full resynchronization ) ` 和 `部分重同步( partial resynchronization )`

#### 部分重同步
主要由三个部分构成
##### 复制偏移量 replication offset

执行复制的双方主从服务器分别会维护一个 复制偏移量 以来决定开始复制的位置
-  主服务器每次向从服务器传播N个字节数据，就将自己的复制偏移值加上N
-  从服务器每次收到主传来的N个字节数据，也将自己的复制偏移量值加上N

![[Redis-3 集群-部分重同步-复制偏移量.png|400]]

#### 复制积压缓冲区 repl_backing_buffer

是主服务器维护的一个固定长度先进先出队列，默认大小为1MB。保存着最近传播的写入命令，并且会为队列每个字节记录相应的复制偏移量，以决定是部分同步还是全量同步
1.  如果 offset 偏移量之后的数据还在复制缓冲区，那么对从服务器执行部分重同步
2.  如果 offset 偏移量不在缓冲区，那么还是执行完整重同步

`repl_backlog_buffer`：它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量复制带来的性能开销。如果从库断开时间太久，repl_backlog_buffer 环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量复制，所以 **repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量复制的概率**。而在 repl_backlog_buffer 中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。

`replication buffer`：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer 中的数据发到 client socket 中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个 client，也会分配一个 buffer，只不过这个 buffer 专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer。


#### 服务器运行ID
主服务器 根据 来同步的从服务器ID 决定之前是否同步过


## 复制实现

#### 步骤1：设置主服务器的地址和端口

```shell
127.0.0.1:12345> SLAVEOF 127.0.0.1 6379
OK
```

SLAVEOF 是个异步命令

#### 步骤2：建立套接字连接

-  从服务器会为这个套接字关联一个专门用于处理复制工作的文件处理器，复制后续接收RDB文件、写命令等
-  主服务器在接受accept从服务器套接字后，会将从服务器做为一个客户端看待

![[Redis-3 集群.png|400]]


#### 步骤3：发送PING命令
PING命令作用：检查 套接字读写状态 和 主服务器 双方是否正常工作
PING命令后会有3种情况
-  如果 主->从 但从不能在规定时间内读取内容，则从状态不佳，断开并重新创建套接字
-  如果 主->从 返回一个错误，则主表示无法处理服务，断开并重新创建套接字
-  如果 从 读取到 “PONG” 回复，则连接正常

#### 步骤4：身份验证

![[Redis-3 集群-1.png|400]]


#### 步骤5：发送端口信息

从服务器执行命令 REPLCONF listening-port < port-number >，向 主服务器 发送 从服务器的监听端口号

#### 步骤6：同步
从 向 主 发送 PSYNC 命令，并将自己的数据库更新至主服务器当前所处的状态。

#### 步骤7：命令传播
主 只要一直将自己执行的写命令发送给从即可，就可以保证主从一致


## 心跳检测

从 会以每秒一次的频率，向主发送命令：
```shell
REPLCONF ACK < replication_offset >
```

### 检测主从间的网络连接状态

如果超过一秒钟没有收到从发来的 ACK 命令，那么主就知道主从之间出现连接问题了

### 辅助实现 min-slaves

Redis 的 `min-slaves-to-write` 和 `min-slaves-max-lag` 可以防止从在 服务器数量少于3个  或  3个从的延迟lag都大于等于10，主拒绝执行写命令


### 检测命令丢失

如果主在从回传的命令中发现当前从的复制偏移量少于自己的，主会根据从提交的复制偏移，在复制积压缓冲区找到从缺少数据，重新发给从。


# Sentinel 哨兵

Sentinel 哨兵是 Redis 的高可用性解决方案：由一个或多个Sentinel组成的系统可以监视任意多个主服务器，以及这些主下属的从，并在被监视的主下线时自动将下线主属下的某个从升级为新的主。

## 获取主从服务器信息

Sentinel 默认会以每十秒一次的频率，通过命令连接向被监视的主发送 INFO 命令获取主当前信息
-  主本身的信息，包括 run_id 域记录的服务器运行ID，以及 role 域记录的服务器角色
-  主下属所有从信息，每个从由 “slave” 字符串开头的行记录

## 检测主观下线状态

默认情况下Sentinel 会以每秒一次的频率向所有与它创建命令连接的实例如主、从、其他Sentinel等发送 PING命令，并通过PING回复来判断实例是否在线
配置 `down-after-millseconds = 50000ms` 那么当 主master 连续 50000毫秒 返回无效回复时，Sentinel 就会将 master 标记为主观下线

## 检测客观下线状态

当Sentinel将一个主判断为主观下线后，为了确认是否真的下线它会同样向其他Sentinel询问，如果接受的数量足够多，Sentinel就会判断为客观下线并对主进行故障转移


## 选举领头Sentinel

Sentinel 设置局部零头的规则是先到先得：最先向目标Sentinel发送 is-master-down-by-addr 设置要求的，而之后接受到所有设置都会被目标Sentinel拒绝。得到半数以上的Sentinel将成为领头。否则将再次选举，就是一个Raft选举算法： **选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举**

https://www.pdai.tech/md/algorithm/alg-domain-distribute-x-raft.html

## 故障转移

### Step1：选出新的主服务器

SLAVEOF no one 将选中的从服务器转换为主服务器。（新的主数据不完备怎么办？）

### Step2：修改从服务器的复制目标


### Step3：将旧的主变为从服务器






# Cluster 集群

Redis Cluster 是 Redis 推荐的分布式解决方案，它将数据自动分片到多个节点，每个节点负责一部分

Redis Cluster 采用主从复制来提高可用性，每个分片都有一个主节点和多个从节点，主节点负责写从节点负责复制数据并处理读请求

Redis Cluster 能自动检测节点故障，可标记不可用 或 从升主等

![[Redis-3 集群-2.png|600]]

# Q&A

###  1、分布式锁
Q：常规

	加锁： SET NX PX + 校验唯一随机值
	解锁： Lua脚本

Q：RedLock

	搞多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。

Q：Redisson框架

	Redisson watchdog或者它实现了RedLock方式

### 2、 缓存问题

Q：缓存穿透

-  问题来源

		缓存穿透是指**缓存和数据库中都没有的数据**，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义

-  解决方案

		接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
		从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
		布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小

Q：缓存穿击

-  问题来源

		缓存击穿是指**缓存中没有但数据库中有的数据**（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。

 - 解决方案

		1、设置热点数据永远不过期。
		2、接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。
		3、加互斥锁

Q3：缓存雪崩
- 问题来源

		缓存雪崩是指缓存中**数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机**。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库

-  解决方案
 
		1、缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
		2、如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
		3、设置热点数据永远不过期。

Q：缓存污染

	缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。

	缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。



Q：Redis性能问题有哪些，如何分析定位？

-  慢日志，慢查询就会导致后面的请求发生排队，客户端查询响应也会延迟
-  bigkey大对象
-  集中过期
	-  1、集中过期key加上一个随机时间，把集中过期时间打散降低过期清理压力
	-  2、Redis 4.0以上开启 lazy-free 机制，当删除过期key时把释放内存操作到后台操作
-  fork耗时严重
