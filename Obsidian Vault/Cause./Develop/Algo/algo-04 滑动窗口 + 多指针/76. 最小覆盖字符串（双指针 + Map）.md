
-  **描述**

	给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串

-  **代码**

```java

Map<Character, Integer> ori = new HashMap<>();  
Map<Character, Integer> cnt = new HashMap<>();

public String minWindow(String s, String t) {  
    int tLen = t.length();  
    for (int i = 0; i < tLen; i++) {  
        char c = t.charAt(i);  
        ori.put(c, ori.getOrDefault(c, 0) + 1);  
    }  
    int l = 0, r = -1;  
    int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;  
    int sLen = s.length();  
    while (r < sLen) {  
        // R日常前进，把结果统计到CNT的集合内（想到了这一步..但感觉复杂度过高，看来还是要坚持走下去才行）  
        ++r;  
        if (r < sLen && ori.containsKey(s.charAt(r))) {  
            cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);  
        }  
        // 满足涵盖条件，则更新长度len，并把L继续前进  
        while (check() && l <= r) {  
            if (r - l + 1 < len) {  
                len = r - l + 1;  
                ansL = l;  
                ansR = l + len;  
            }  
            if (ori.containsKey(s.charAt(l))) {  
                cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);  
            }  
            ++l;  
        }  
    }  
    return ansL == -1 ? "" : s.substring(ansL, ansR);  
}  
  
private boolean check() {  
    // 每次都要校验窗口内的字符，和需要的字符之间的数量？？？ -- 时间复杂度过高  
    Iterator<Map.Entry<Character, Integer>> iter = ori.entrySet().iterator();  
    while (iter.hasNext()) {  
        Map.Entry entry = iter.next();  
        Character key = (Character) entry.getKey();  
        Integer val = (Integer) entry.getValue();  
        if (cnt.getOrDefault(key, 0) < val) {  
            return false;  
        }  
    }  
    return true;  
}

```