
给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文串返回 `s` 所有可能的分割方案

```java
	boolean[][] f;  
    List<List<String>> ret = new ArrayList<>();  
    List<String> ans = new ArrayList<>();  
    int n;  
  
    public List<List<String>> xxx_partition_131(String s) {  
        n = s.length();  
        f = new boolean[n][n];  
        for (int i = 0; i < n; ++i) {  
            Arrays.fill(f[i], true);  
        }  
        // 1、找到字符的回文串（对比下面方式，推荐这种方式 简答明了）  
        for (int i = n - 1; i >= 0; --i) {  
            for (int j = i + 1; j < n; ++j) {  
                f[i][j] = (s.charAt(i) == s.charAt(j)) && f[i + 1][j - 1];  
            }  
        }  
        // 2、深度递归树找到[i,j]  
        dfs(s, 0);  
        return ret;  
    }  
  
    private void dfs(String s, int i) {  
        if (i == n) {  
            ret.add(new ArrayList<>(ans));  
            return;        }  
        // for循环下一个树节点是从上一个的尾开始  
        for (int j = i; j < n; ++j) {  
            if (f[i][j]) {  
                ans.add(s.substring(i, j + 1));  
                dfs(s, j + 1);  
                // ans作为唯一一个list存储，下一层节点结束的时候要移除再返回上一层  
                ans.remove(ans.size() - 1);  
            }  
        }  
    }

```

1、通过动态规划找到整个字符的回文区间 [ i, j ]
2、再深度递归，判断 i -> j 区间内是否回文

