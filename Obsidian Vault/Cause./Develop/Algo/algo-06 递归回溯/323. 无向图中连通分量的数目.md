
-  **描述**

	你有一个包含 `n` 个节点的图。给定一个整数 `n` 和一个数组 `edges` ，其中 `edges[i] = [ai, bi]` 表示图中 `ai` 和 `bi` 之间有一条边。
	
	返回 _图中已连接分量的数目_ 


-  **解答**

```java

public int countComponents(int n, int[][] edges) {  
    int components = 0;  
    int[] visited = new int[n];  
    // 数组列表 或者 哈希列表都可  
    List<Integer>[] adjList = new ArrayList[n];  
    for (int i = 0; i < n; i++) {  
        adjList[i] = new ArrayList<>();  
    }  
    for (int i = 0; i < edges.length; i++) {  
        // 双向联通的：a->b b->a  
        adjList[edges[i][0]].add(edges[i][1]);  
        adjList[edges[i][1]].add(edges[i][0]);  
    }  
  
    for (int i = 0; i < n; i++) {  
        if (visited[i] == 0) {  
            // 这么简单的DFS.. 怎么想不到呢  
            components++;  
            countComponentsDFS(adjList, visited, i);  
        }  
    }  
    return components;  
}  
  
private void countComponentsDFS(List<Integer>[] adjList, int[] visited, int startNode) {  
    visited[startNode] = 1;  
    for (int i = 0; i < adjList[startNode].size(); i++) {  
        if (visited[adjList[startNode].get(i)] == 0) {  
            countComponentsDFS(adjList, visited, adjList[startNode].get(i));  
        }  
    }  
}

```