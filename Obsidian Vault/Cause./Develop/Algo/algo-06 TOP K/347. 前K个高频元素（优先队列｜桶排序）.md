
-  **描述**

	一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案


-  **解答**

```java

// 时间复杂度：O(logN)
public static List<Integer> topKFrequent(int[] nums, int k) {  
    // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值  
    HashMap<Integer, Integer> map = new HashMap();  
    for (int num : nums) {  
        if (map.containsKey(num)) {  
            map.put(num, map.get(num) + 1);  
        } else {  
            map.put(num, 1);  
        }  
    }  
    
    // 小顶堆：顶部最小，每次跟顶部最小值比较，大于最小值则进入k大小内
    PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparingInt(map::get));  
    for (Integer key : map.keySet()) {  
        if (pq.size() < k) {  
            pq.add(key);    
        } else if (map.get(key) > map.get(pq.peek())) {  
            pq.remove();  
            pq.add(key);  
        }  
    }  
 
    List<Integer> res = new ArrayList<>();  
    while (!pq.isEmpty()) {  
        res.add(pq.remove());  
    }  
    return res;  
}  


// 时间复杂度：O(N)
public List<Integer> topKFrequent_v2(int[] nums, int k) {  
    // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值  
    HashMap<Integer, Integer> map = new HashMap();  
    for (int num : nums) {  
        if (map.containsKey(num)) {  
            map.put(num, map.get(num) + 1);  
        } else {  
            map.put(num, 1);  
        }  
    }  
    // 桶排序：将出现次数作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标  
    List<Integer>[] list = new List[nums.length + 1];  
    for (int key : map.keySet()) {  
        int i = map.get(key);  
        if (list[i] == null) {  
            list[i] = new ArrayList();  
        }  
        list[i].add(key);  
    }  
    // 倒序遍历数组获取出现顺序从大到小的排列  
    List<Integer> res = new ArrayList();  
    for (int i = list.length - 1; i >= 0 && res.size() < k; i--) {  
        if (list[i] == null) {  
            continue;  
        }  
        res.addAll(list[i]);  
    }  
    return res;  
}
```


-  **思考**

	1.  关于优先队列 `PriorityQueue<Integer>` --> 二叉树的增加（上移）、删除（下移）都是 O(logn)
	2.  关于桶排序 `List<Integer>[]`  --> O(N)


-  **其他：桶排序求TOP K**

```java

public int findKthLargest(int[] nums, int k) {
    int maxVal = findMax(nums);
    int[] count = new int[maxVal + 1];
    // 维护一个桶数组
    for (int num : nums) {
        count[num]++;
    }
    // 桶数计数
    int countK = 0;
    for (int i = maxVal; i >= 0; i--) {
        if (count[i] > 0) {
            countK += count[i];
            if (countK >= k) {
                return i;
            }
        }
    }
    return -1; 
}

private int findMax(int[] nums) {
    int max = nums[0];
    for (int num : nums) {
        if (num > max) {
            max = num;
        }
    }
    return max;
}

```