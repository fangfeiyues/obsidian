
-  **描述**

	一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案


-  **解答**

```java

// 时间复杂度：O(logN)
public static List<Integer> topKFrequent(int[] nums, int k) {  
    // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值  
    HashMap<Integer, Integer> map = new HashMap();  
    for (int num : nums) {  
        if (map.containsKey(num)) {  
            map.put(num, map.get(num) + 1);  
        } else {  
            map.put(num, 1);  
        }  
    }  
    
    // 最小堆保存频率最大的k个元素  
    PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.comparingInt(map::get));  
    for (Integer key : map.keySet()) {  
        if (pq.size() < k) {  
            pq.add(key);  
            // key出现的频率是否大于大顶堆的最小值
        } else if (map.get(key) > map.get(pq.peek())) {  
            pq.remove();  
            pq.add(key);  
        }  
    }  
    
    // 依次取出大顶堆堆中的元素  
    List<Integer> res = new ArrayList<>();  
    while (!pq.isEmpty()) {  
        res.add(pq.remove());  
    }  
    return res;  
}  


// 时间复杂度：O(N)
public List<Integer> topKFrequent_v2(int[] nums, int k) {  
    // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值  
    HashMap<Integer, Integer> map = new HashMap();  
    for (int num : nums) {  
        if (map.containsKey(num)) {  
            map.put(num, map.get(num) + 1);  
        } else {  
            map.put(num, 1);  
        }  
    }  
    // 桶排序：将出现次数作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标  
    List<Integer>[] list = new List[nums.length + 1];  
    for (int key : map.keySet()) {  
        int i = map.get(key);  
        if (list[i] == null) {  
            list[i] = new ArrayList();  
        }  
        list[i].add(key);  
    }  
    // 倒序遍历数组获取出现顺序从大到小的排列  
    List<Integer> res = new ArrayList();  
    for (int i = list.length - 1; i >= 0 && res.size() < k; i--) {  
        if (list[i] == null) {  
            continue;  
        }  
        res.addAll(list[i]);  
    }  
    return res;  
}
```


-  **思考**

	1.  关于优先队列 `PriorityQueue<Integer>` --> 二叉树的增加（上移）、删除（下移）都是O(logn)
	2.  关于桶排序 `List<Integer>[]`  --> O(N)