
-  **描述**

	小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。
	
	除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。
	
	给定二叉树的 `root` 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额


-  **解答**

```java

public int rob(TreeNode root) {  
    int[] rootStatus = rob_dfs(root);  
    return Math.max(rootStatus[0], rootStatus[1]);  
}  
  
private int[] rob_dfs(TreeNode node) {  
    // 到当前值的可能节点也可能没选节点，根据这两种情况分析  
    if (node == null) {  
        return new int[]{0, 0};  
    }  
    // 后续遍历：先看左右节点，在看根节点  
    int[] l = rob_dfs(node.left);  
    int[] r = rob_dfs(node.right);  
    // 节点选中：当前节点值 + 左未 + 右未  
    int selected = node.val + l[1] + r[1];  
    // 节点未选中：左可选中亦可未选中，右可选中亦可未选中  
    int notSelected = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);  
    return new int[]{selected, notSelected};  
}

```