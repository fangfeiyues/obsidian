给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间

**示例 1：**

**输入：**nums = [1,3,4,2,2]
**输出：**2

**示例 2：**

**输入：**nums = [3,1,3,4,2]
**输出：**3

**示例 3 :**

**输入：**nums = [3,3,3,3,3]
**输出：**3


```java

public int xxx_findDuplicate_287(int[] nums) {  
    // 解决方案必须不修改数组nums 且 只用常量级O(1)的额外空间  
    // 二分法：findDuplicate_4_mid -- 常量级的时间复杂度和空间复杂    
    // 快慢指针：findDuplicate_4_slow -- 保证了在快慢指针能在重复节点相遇    
    return 0;  
}  
  
private int findDuplicate_4_mid(int[] nums) {  
    int left = 1;  
    int right = nums.length - 1;  
    while (left < right) {  
        int mid = (left + right) / 2;  
        int cnt = 0;  
        for (int num : nums) {  
            if (num <= mid) {  
                cnt++;  
            }  
        }  
        // 多数都小于数字mid的话说明多的数比mid小，则说明值在[1,数字mid间]  
        if (cnt > mid) {  
            right = mid;  
        } else {  
            left = mid + 1;  
        }  
    }  
    return left;  
}  
  
private int findDuplicate_4_slow(int[] nums) {  
    // 通过nums[n] --> nums[nums[n]]的指向构建成一个环（不在意环的位置是否是链表最后只要保证环存在即可）  
    int slow = nums[0];  
    int fast = nums[nums[0]];  
    while (slow != fast) {  
        slow = nums[slow];  
        fast = nums[nums[fast]];  
    }  
    fast = 0;  
    while (slow != fast) {  
        slow = nums[slow];  
        fast = nums[fast];  
    }  
    return slow;  
}

```