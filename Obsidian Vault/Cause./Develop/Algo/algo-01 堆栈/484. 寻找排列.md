
-  **描述**

	由范围 `[1,n]` 内所有整数组成的 `n` 个整数的排列 `perm` 可以表示为长度为 `n - 1` 的字符串 `s` ，其中:
	
	- 如果 `perm[i] < perm[i + 1]` ，那么 `s[i] == 'I'`
	- 如果 `perm[i] > perm[i + 1]` ，那么 `s[i] == 'D'` 。
	
	给定一个字符串 `s` ，重构字典序上最小的排列 `perm` 并返回它


-  **解答**

```java
private static int[] findPermutation_stack(String s) {  
    int[] res = new int[s.length() + 1];  
    int point = 0;  
    // 利用堆栈，倒着的输出[]  
    Stack<Integer> stack = new Stack<>();  
    stack.add(1);  
    for (int i = 1; i < s.length() + 1; i++) {  
        int num = i + 1;  
        // 如果前一个是 D 则，当前进栈要保持减  
        if (s.charAt(i - 1) == 'D' || (i < s.length() && s.charAt(i) == 'D')) {  
            stack.push(num);  
        } else {  
            // 如果前一个是 I 判断stack是否为空  
            while (!stack.isEmpty()) {  
                res[point++] = stack.pop();  
            }  
            res[point++] = num;  
        }  
    }  
    while (!stack.isEmpty()) {  
        // 最后可能 D 结尾  
        res[point++] = stack.pop();  
    }  
    return res;  
}

```


-  **思路**

	乍一眼看到题目后，是有些困难的。
	在知道栈的思路后，怎么也理不清 ‘D’ 的出栈入栈顺序