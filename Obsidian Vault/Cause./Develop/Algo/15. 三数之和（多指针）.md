
-  **描述**

```text
整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]]` 满足 i != j、`i != k` 且 `j != k` ，同时还满足 nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。注意：答案中不可以包含重复的三元组
```


- **题解**

3指针减少时间复杂度

```java
 public List<List<Integer>> xxx_threeSum_15(int[] nums) {  
    Arrays.sort(nums);  
    int len = nums.length;  
    List<List<Integer>> ans = new ArrayList<>();  
    // 第1步：循环第一个节点  
    for (int first = 0; first < len; ++first) {  
        if (first > 0 && nums[first] == nums[first - 1]) {  
            continue;  
        }  
        int third = len - 1;  
        int target = -nums[first];  
        // 第2步：first、third 再加一个 second 遍历 
        for (int second = first + 1; second < len; ++second) {  
            if (second > first + 1 && nums[second] == nums[second - 1]) {  
                continue;  
            }  
            while (second < third && nums[second] + nums[third] > target) {  
                --third;  
            }  
            // 第3步：第二个指针和第三个指针相同的时候，说明相碰了则没有满足的条件  
            if (second == third) {  
                break;  
            }  
            if (nums[second] + nums[third] == target) {  
                List<Integer> list = new ArrayList<>();  
                list.add(nums[first]);  
                list.add(nums[second]);  
                list.add(nums[third]);  
                ans.add(list);  
            }  
        }  
    }  
       return ans;  
}
```


- **变型题01**

```java

/**  
 * 16.给你一个长度为 n 的整数数组 nums 和 一个目标值 target。
 * 请你从 nums 中选出三个整数，使它们的和与 target 最接近，返回这三个数的和
 * @param nums  
 * @param target  
 * @return  
 */  
public int threeSumClosest(int[] nums, int target) {  
    int len = nums.length;  
    if (len <= 3) {  
        return nums[0] + nums[1] + nums[2];  
    }  
    // 第一步，先排序  
    Arrays.sort(nums);  
    int best = 1000000;  
    for (int i = 0; i < len; i++) {  
        if (i > 0 && nums[i] == nums[i - 1]) {  
            // 排除前后重复的
            continue;  
        }  
        // 第二步，找[起,止]位置  
        int j = i + 1, k = len - 1;  
        while (j < k) {  
            int sum = nums[i] + nums[j] + nums[k];  
            if (sum == target) {  
                return target;  
            }  
            // 第三步，根据总值与target的大小决定指针移动方向 ！！！
            if (sum < target) {  
                j++;  
            } else {  
                k--;  
            }  
            best = Math.min(best, Math.abs(sum - target));  
        }  
    }  
    return best;  
}

```