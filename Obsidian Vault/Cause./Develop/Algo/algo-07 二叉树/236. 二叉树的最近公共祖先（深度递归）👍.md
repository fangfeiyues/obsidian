
-  **描述**

	给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
	
	最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”


-  **解法**

```java

public TreeNode lowestCommonAncestor(TreeNode cur, TreeNode p, TreeNode q) {  
    if (cur == null || cur == p || cur == q) {  
        return cur;  
    }  
    // 1、先左侧节点一撸到底；
    // 2、再逐步回塑右侧节点；
    // 3、在当前节点视角判断子树下是否存在指定节点，存在两则返回cur存在一则返回left/right都不存在则null  
    TreeNode left = lowestCommonAncestor(cur.left, p, q);  
    TreeNode right = lowestCommonAncestor(cur.right, p, q);  
    
    // ！！！二叉树的后序遍历：cur节点的左右子树是否存在指定节点，不存在即返回另一个节点都存在则返回当前节点。然后一直把节点往上回溯比较！！！  
    if (left == null) {  
        // left为空：说明当前节点的左子树一撸到底没有遇到指定节点，那就在右节点则直接返回右节点值  
        return right;  
    }  
    if (right == null) {  
        // right为空：说明当前节点的右子树一撸到底没有遇到指定节点，那就在左节点则直接返回左节点值  
        return left;  
    }  
    // 如果left和right都不为空：说明这两个节点一个在cur的左子树上一个在cur的右子树上  
    // return的数值代表啥？？？ - 代表当前节点可能所存在的树    return cur;

```