
-  **题目描述**

	给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小。其中，最大指的是子树节点数最多的。
	
	二叉搜索树（BST）中的所有节点都具备以下属性：
	- 左子树的值小于其父（根）节点的值
	- 右子树的值大于其父（根）节点的值
	
	注意：子树必须包含其所有后代


-  **解答**

```java
int largestBSTSubtreeRes = 0;  
  
public int largestBSTSubtree(TreeNode root) {  
    if (root == null) {  
        return 0;  
    }  
    largestBSTSubtreeDFS(root);  
    return largestBSTSubtreeRes;  
}  
  
private Node largestBSTSubtreeDFS(TreeNode root) {  
    if (root.left == null && root.right == null) {  
        largestBSTSubtreeRes = Math.max(largestBSTSubtreeRes, 1);  
        return new Node(root.val, root.val, 1);  
    }  
    int min = root.val;  
    int max = root.val;  
    int size = 1;  
    boolean valid = true;  
    // 左子树：存在子树 且 根节点大于子树最大值 则重置节点size、L、R  
    if (root.left != null) {  
        Node L = largestBSTSubtreeDFS(root.left);  
        if (L.size != -1 && root.val > L.max) {  
            size += L.size;  
            min = L.min;  
        } else {  
            valid = false;  
        }  
    }  
    // 右子树：存在子树 且 根节点小于子树最小值 则重置节点size、L、R  
    if (root.right != null) {  
        Node R = largestBSTSubtreeDFS(root.right);  
        if (R.size != -1 && root.val < R.min) {  
            size += R.size;  
            max = R.max;  
        } else {  
            valid = false;  
        }  
    }  
    // 如果左右子树任意一个非BST，那么根节点都不是BST  
    if (valid) {  
        largestBSTSubtreeRes = Math.max(size, largestBSTSubtreeRes);  
        return new Node(min, max, size);  
    }  
    return new Node(-1, -1, -1);  
}  
  
class Node {  
    //最小值  
    int min;  
    //最大值  
    int max;  
    //节点个数，如果不是bst则为-1  
    int size;  
  
    Node(int min, int max, int size) {  
        this.min = min;  
        this.max = max;  
        this.size = size;  
    }  
}

```