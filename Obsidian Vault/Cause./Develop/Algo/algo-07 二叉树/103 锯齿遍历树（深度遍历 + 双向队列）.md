
-  **描述**

	给你二叉树的根节点 root ，返回其节点值的锯齿形层序遍历（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）

- **代码**

```java
public static List<List<Integer>> xxx_zigzagLevelOrder_103(TreeNode root) {  
    // note：不用自己处理锯齿，借用双端队列的offerLast、offerFirst来处理左右端节点  
    List<List<Integer>> ans = new LinkedList<>();  
    if (root == null) {  
        return ans;  
    }  
    boolean isOrderLeft = true;  
    // tips: Queue队列一般用LinkedList实现，有可快速插入删除支持大数据等好处  
    Queue<TreeNode> nodeQueue = new LinkedList<>();  
    nodeQueue.offer(root);  
    while (!nodeQueue.isEmpty()) {  
        // step1：用了一个双向队列Deque存储结果，都是从左到右遍历 然后 利用双端队列选择插左还是插右  
        Deque<Integer> levelList = new LinkedList<>();  
        int size = nodeQueue.size();  
        for (int i = 0; i < size; ++i) {  
            TreeNode curNode = nodeQueue.poll();  
            if (isOrderLeft) {  
                levelList.offerLast(curNode.val);  
            } else {  
                levelList.offerFirst(curNode.val);  
            }  
            if (curNode.left != null) {  
                nodeQueue.offer(curNode.left);  
            }  
            if (curNode.right != null) {  
                nodeQueue.offer(curNode.right);  
            }  
        }  
        ans.add(new LinkedList<>(levelList));  
        isOrderLeft = !isOrderLeft;  
    }  
    return ans;  
}

```

-  **思考**

	1.  双端队列 Deque 来保证左右插入的能力