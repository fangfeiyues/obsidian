-  **描述**

	给你链表的头结点 `head` ，请将其按 升序 排列并返回排序后的链表

- **代码**

```java
/**  
 * 148.链表的头结点 head ，请将其按升序排列并返回排序后的链表 * * [4,2,7,5,9] -> [2,4,5,7,9] * * @param head 2024-02-22 again  
 * @return  
 */  
public ListNode sortList(ListNode head) {  
    // 归并排序：数组不断按中间节点分割成最小，然后递归合并排序。先归一再合并  
    if (head == null || head.next == null) {  
        return head;  
    }  
    ListNode middle = findMiddleNode(head);  
    ListNode rightHead = middle.next;  
    // 中间侧断开保证下一次遍历只有前半部分（由于后续不会再用到这个链表所以不用担心链表接不上的问题）  
    middle.next = null;  
    ListNode left = sortList(head);  
    ListNode right = sortList(rightHead);  
    return mergeListNode(left, right);  
}  
  
private ListNode findMiddleNode(ListNode head) {  
    if (head == null || head.next == null) {  
        return head;  
    }  
    ListNode slow = head;  
    // 因为要从中间分成两截，跟正常的快慢不一样，fast提前走保证middle在中间点左侧  
    ListNode fast = head.next.next;  
    while (fast != null && fast.next != null) {  
        slow = slow.next;  
        fast = fast.next.next;  
    }  
    return slow;  
}  
  
private ListNode mergeListNode(ListNode a, ListNode b) {  
    ListNode sentry = new ListNode(-1);  
    ListNode curr = sentry;  
    while (a != null && b != null) {  
        if (a.val < b.val) {  
            curr.next = a;  
            a = a.next;  
        } else {  
            curr.next = b;  
            b = b.next;  
        }  
        curr = curr.next;  
    }  
    curr.next = a == null ? b : a;  
    return sentry.next;  
}
```