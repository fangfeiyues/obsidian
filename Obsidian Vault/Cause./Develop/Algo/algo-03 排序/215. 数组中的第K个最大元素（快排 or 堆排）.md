
-  **描述**

	给定整数数组 `nums` 和整数 `k`，请返回数组中第 k 个最大的元素
	请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素
	你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题


```java

// 快排：递归找到分区点（第一位），排到改在的位置上。时间复杂度：
public int findKthLargestByQuick(int[] _nums, int k) {  
    int n = _nums.length;  
    return quickSelect(_nums, 0, n - 1, n - k);  
}  
  
int quickSelect(int[] nums, int l, int r, int k) {  
    if (l == r) {  
        return nums[k];  
    }  
    // 双指针 i 和 j 交叉后，即 x 在自己的位置上  
    int partition = nums[l], i = l - 1, j = r + 1;  
    while (i < j) {  
        do i++; while (nums[i] < partition);  
        do j--; while (nums[j] > partition);  
        if (i < j) {  
            int tmp = nums[i];  
            nums[i] = nums[j];  
            nums[j] = tmp;  
        }  
    }  
    if (k <= j) {  
        return quickSelect(nums, l, j, k);  
    } else {  
        return quickSelect(nums, j + 1, r, k);  
    }  
}


```


-  **快排**

	1.  时间复杂度：O(nlogn)
	2.  核心怎么把分区点 partition，放到正确的位置。i = l - 1,  j = r + 1 


```java

public int findKthLargestByHeap(int[] nums, int k) {  
    int heapSize = nums.length;  
    buildMaxHeap(nums, heapSize);  
    for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {  
        swap(nums, 0, i);  
        --heapSize;  
        maxHeapify(nums, 0, heapSize);  
    }  
    return nums[0];  
}  
  
public void buildMaxHeap(int[] a, int heapSize) {  
    // heapSize / 2  
    for (int i = heapSize / 2; i >= 0; --i) {  
        maxHeapify(a, i, heapSize);  
    }  
}  
  
public void maxHeapify(int[] a, int i, int heapSize) {  
    int l = i * 2 + 1, r = i * 2 + 2, largest = i;  
    if (l < heapSize && a[l] > a[largest]) {  
        largest = l;  
    }  
    if (r < heapSize && a[r] > a[largest]) {  
        largest = r;  
    }  
    if (largest != i) {  
        swap(a, i, largest);  
        maxHeapify(a, largest, heapSize);  
    }  
}  
  
public void swap(int[] a, int i, int j) {  
    int temp = a[i];  
    a[i] = a[j];  
    a[j] = temp;  
}

```


-  **堆排序**

	1.  时间复杂度 O(nlogn)，建堆的时间代价是 O(n)，删除的总代价是 O(klogn)
	2.  从下到上，找到最大值