
-  **描述**

	**超级丑数** 是一个正整数，并满足其所有质因数都出现在质数数组 `primes` 中。
	
	给你一个整数 `n` 和一个整数数组 `primes` ，返回第 `n` 个 **超级丑数** 。
	
	题目数据保证第 `n` 个 **超级丑数** 在 **32-bit** 带符号整数范围内

-  **解答**

```java

public int nthSuperUglyNumber(int n, int[] primes) {  
    // 记录第n次的最小数  
    int[] dp = new int[n + 1];  
    int m = primes.length;  
    // 记录丑数列表的每个数字累加了多少次  
    int[] pointers = new int[m];  
    // 记录point次乘积后的最小值  
    int[] nums = new int[m];  
    Arrays.fill(nums, 1);  
    for (int i = 1; i <= n; i++) {  
        int minNum = Arrays.stream(nums).min().getAsInt();  
        dp[i] = minNum;  
        // 循环找到本次的最小值是谁，然后把最小值继续推进：  
        for (int j = 0; j < m; j++) {  
            if (nums[j] == minNum) {  
                // pointers[j]: j指针执行次数；  
                pointers[j]++;  
                // dp[pointers[j]] j指针执行几次后，dp产生的最小值？？？（死记吧）  
                // nums[j]已经是最小值，要继续推进，下一个值就是？？？                
                nums[j] = dp[pointers[j]] * primes[j];  
                // - nums[j] = pointers[j] * primes[j]; // 错误：不是乘积的关系，是幂的关系  
            }  
        }  
    }  
    return dp[n];  
}

```


-  **变形题**

```java

/**  
 * 264.一个整数n，返回第n个丑数（丑数就是质因子只包含 2、3 和 5 的正整数） * * n = 10 ==> 12 [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 丑数组成的前10列表 
 * @param n  
 * @return  
 */  
public int xxx_nthUglyNumber_264(int n) {  
    int[] dp = new int[n];  
    dp[0] = 1;  
    int p2 = 0, p3 = 0, p5 = 0;  
    for (int i = 1; i < n; i++) {  
        // 2*2*2.. ｜ 3*3*3..  | 5*5*5.. 之间的比较  
        int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;  
        dp[i] = Math.min(num2, Math.min(num3, num5));  
        System.out.println(dp[i] + " ");  
        if (dp[i] == num2) {  
            p2++;  
        }  
        if (dp[i] == num3) {  
            p3++;  
        }  
        if (dp[i] == num5) {  
            p5++;  
        }  
    }  
    return dp[n - 1];  
}

```