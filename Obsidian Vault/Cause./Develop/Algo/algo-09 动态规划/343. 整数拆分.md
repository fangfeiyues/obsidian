
-  **描述**

	给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。
	
	返回 可以获得的最大乘积

-  **解答**

```java
public int xxx_integerBreak_343(int n) {  
    // 暴力点就DFS  
    // dp[i] 表示拆分 i 可获得的最大乘积    int[] dp = new int[n + 1];  
    for (int i = 2; i <= n; i++) {  
        int tmpMax = 0;  
        /*  
            先将 i 分解为 j 和 i - j            
            如果 i - j 不再分解，那么 dp[i] = j * (i - j)            
            如果 i - j 继续分解，那么 dp[i] = j * dp[i - j]            
            其中 j 的取值范围是 [1, i - 1]，所以需要遍历 j 的所有可能情况        */        
            for (int j = 1; j < i; j++) {  
            tmpMax = Math.max(tmpMax, Math.max(j * (i - j), j * dp[i - j]));  
        }  
        dp[i] = tmpMax;  
    }  
    return dp[n];  
}

```


-  **思考**

	题目本身不难，还是根据 `dp[i-j] -> dp[i]` 的问题，但这里有个 `j * (i - j)` 的逻辑比较奇怪？？？