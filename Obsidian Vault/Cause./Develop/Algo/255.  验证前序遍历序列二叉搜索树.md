给定一个 **无重复元素** 的整数数组 `preorder` ， _如果它是以二叉搜索树的**先序遍历**排列_ ，返回 `true`

```java

public boolean verifyPreorder(int[] preorder) {  
    Stack<Integer> stack = new Stack<>();  
    int max = Integer.MIN_VALUE;  
    for (int cur : preorder) {  
        // 先序拐点在根节点：后续右子树节点都要大于此节点  
        while (!stack.isEmpty() && cur > stack.peek()) {  
            max = stack.pop();  
        }  
        // 右子树的节点都应该大于左子树的根节点  
        if (cur < max) {  
            return false;  
        }  
        stack.push(cur);  
    }  
    return true;  
}

```

1、核心是找到左右子树的分界点，然后判断右子树是否都大于左子树的根节点。
2、另外二叉树的核心一般都是用栈来实现


```java
// 验证后序遍历序列二叉搜索树
private boolean verifyPreorder_after(int[] preorder) {  
    if (preorder == null || preorder.length == 0) {  
        return false;  
    }  
    Stack<Integer> stack = new Stack<>();  
    int max = Integer.MIN_VALUE;  
    for (int cur : preorder) {  
        if (cur < max) {  
            return false;  
        }  
        // 后续拐点在根节点：后续右子树节点都要大于此节点  
        while (!stack.isEmpty() && stack.peek() < cur) {  
            max = stack.pop();  
        }  
        stack.push(cur);  
    }  
    return true;  
}

```