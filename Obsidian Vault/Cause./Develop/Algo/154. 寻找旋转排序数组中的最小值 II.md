数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 给你一个可能存在 **重复** 元素值的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素
 `nums = [0,1,4,4,5,6,7]` --> 旋转4次后  `[4,5,6,7,0,1,4]`

```java
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        while (low < high) {
            int pivot = low + (high - low) / 2;
            // piovt < high 说明区间升序是正常的
            if (nums[pivot] < nums[high]) {
                high = pivot;
            } else if (nums[pivot] > nums[high]) {
                low = pivot + 1;
            } else {
            // 如果pivot和high一样大小，从high位置向前走！！！
            // （二分就是要把各种可能都想一边 各种变种）
                high -= 1;
            }
        }
        return nums[low];
    }

```

1、对于排序、查找最小值等问题，毫无疑问最好用的还是二分法
2、二分法要灵活应用
